<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | </title>
    <link>https://fabiangunzinger.github.io/post/</link>
      <atom:link href="https://fabiangunzinger.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 24 Apr 2022 09:02:49 +0100</lastBuildDate>
    <image>
      <url>https://fabiangunzinger.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Posts</title>
      <link>https://fabiangunzinger.github.io/post/</link>
    </image>
    
    <item>
      <title>Analysis Checklist</title>
      <link>https://fabiangunzinger.github.io/post/analysis-checklist/</link>
      <pubDate>Sun, 24 Apr 2022 09:02:49 +0100</pubDate>
      <guid>https://fabiangunzinger.github.io/post/analysis-checklist/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Python dictionaries</title>
      <link>https://fabiangunzinger.github.io/post/python-dictionaries/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/python-dictionaries/</guid>
      <description> &lt;iframe
       src=&#34;./python-dictionaries.html&#34;
       width=&#34;90%&#34;
       height=&#34;6700px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Heaps</title>
      <link>https://fabiangunzinger.github.io/post/heaps/</link>
      <pubDate>Fri, 25 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/heaps/</guid>
      <description> &lt;iframe
       src=&#34;./heaps.html&#34;
       width=&#34;90%&#34;
       height=&#34;3500px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://fabiangunzinger.github.io/post/git/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/git/</guid>
      <description>&lt;p&gt;My evolving notes and on how to effectively use Git and GitHub.&lt;/p&gt;
&lt;h2 id=&#34;git&#34;&gt;Git&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Evolution of version control systems (and their shortcomings): from having
&lt;strong&gt;differently named files and folders&lt;/strong&gt; (error prone and inefficient) to
&lt;strong&gt;local version control systems (LVCs)&lt;/strong&gt; where files are checked out from a
locally hosted database that contains the entire history (single point of
failure and impractical for collaboration) to &lt;strong&gt;centralized version control
systems (CVCSs)&lt;/strong&gt; where files are checked out from a server-hosted database
(single point of failure) to &lt;strong&gt;distributed version control systems (DVCs)&lt;/strong&gt;
where files and a database containing the entire history are checked out from
a served-hosted database, so that each local node contains all information
stored on the server (content on server can easily be restored in case of
failure).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git stores data as snapshots: at each new commit, modified files are replaced
with a snapshot of their new state, while unmodified files are replaced with
a link to the previous snapshot.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In a basic workflow I edit a file in the &lt;em&gt;working tree&lt;/em&gt; (the locally checked
out version of the project), add them to the &lt;em&gt;staging area&lt;/em&gt; (also called
&lt;em&gt;index&lt;/em&gt;), &lt;em&gt;commit&lt;/em&gt; them to the local database, and finally push them to the
remote database on GitHub.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Neither &lt;em&gt;main&lt;/em&gt; (or, formerly, &lt;em&gt;master&lt;/em&gt;), nor &lt;em&gt;origin&lt;/em&gt; have any special
significance in Git. The reason they are widely used is that &lt;em&gt;main&lt;/em&gt; is the
default name for the starting branch when running &lt;code&gt;git init&lt;/code&gt; and &lt;em&gt;origin&lt;/em&gt; is
the default name for the remote repository when running &lt;code&gt;git clone&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Git stores a single file as a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_large_object&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blob&lt;/a&gt;, which is a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Backronym&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;backronym&lt;/a&gt; for &lt;em&gt;binary large
object&lt;/em&gt; and is a collection of binary data. It can store any type of data
including multimedia files and images. Blobs in the git object database are
stored named with a SHA-1 hash key of their content and containing the &lt;a href=&#34;https://stackoverflow.com/a/48959460/13666841&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;exact
same&lt;/a&gt; content as the file
would on my filesystem.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;interacting-with-remotes&#34;&gt;Interacting with remotes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;remote repository&lt;/em&gt; is a version of the project that&amp;rsquo;s hosted on a server,
in my case always on GitHub. The default name Git assigns to the remote when
I clone it is &lt;em&gt;origin&lt;/em&gt;. (Technically, the remote could also be hosted on my
machine but in a separate location from my working copy.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; downloads all new objects from the remote repository
(e.g.  including references to new branches) but does not automatically merge
these objects into my local work. &lt;code&gt;git pull&lt;/code&gt; fetches and automatically merges
the remote version of the local branch I&amp;rsquo;m currently on and merges it if the
current branch is set up to track the remote. By default, &lt;code&gt;git clone&lt;/code&gt; sets up
my local &lt;code&gt;main&lt;/code&gt; branch to track the remote version, named &lt;code&gt;origin/main&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To share work with the remote, I can use &lt;code&gt;git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; (e.g.
to share work from my local &lt;code&gt;main&lt;/code&gt; branch with &lt;code&gt;origin/main&lt;/code&gt;, I can do &lt;code&gt;git push origin main&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;undoing-things&#34;&gt;Undoing things&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Cardinal rule: don&amp;rsquo;t push stuff before you&amp;rsquo;re fully happy with it. Changing
your local history is easy, changing the history on the server isn&amp;rsquo;t.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Changing message of last commit: (with an empty index) run &lt;code&gt;git commit --amend&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Changing the content of the last commit: stage changes you want to add, then
run &lt;code&gt;git commit --amend&lt;/code&gt;. If you don&amp;rsquo;t want to change the commit message,
append &lt;code&gt;--no-edit&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unstaging a staged file: &lt;code&gt;git restore --staged &amp;lt;pathspec&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Undoing changes in the working directory and reverting a file to its state
after the last commit: &lt;code&gt;git restore &amp;lt;pathspec&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Changing multiple commits (edit, reorder, squash, delete, split,
etc.): &lt;code&gt;git rebase -i HEAD~#&lt;/code&gt;, where &lt;code&gt;#&lt;/code&gt; is the parent of the last commit you
want to edit (e.g. if you want to edit the last 3 commits, &lt;code&gt;HEAD~3&lt;/code&gt; will
select commits &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;HEAD~1&lt;/code&gt;, and &lt;code&gt;HEAD~2&lt;/code&gt;). More in
&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;docs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I&amp;rsquo;ve accidentally overwritten a file with content I meant to place in a
new file, and now want to 1) save the new content under a different name and
2) restore the file I&amp;rsquo;ve overwritten. Solution: Just save the new content
under a new name (temporarily deleting the file I&amp;rsquo;ve accidentally
overwritten, and then use &lt;code&gt;git restore &amp;lt;name_of_overwritten_file&amp;gt;&lt;/code&gt; to restore
the old version of the overwritten file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I&amp;rsquo;ve deleted one or more commits (e.g. by using a hard reset) that I need to
recover. First thing to try: run &lt;code&gt;git reflog&lt;/code&gt; to get a log of commits HEAD
pointed to. Once I&amp;rsquo;ve identified the commit I need (ab1af) I can create a new branch
that points to it using &lt;code&gt;git branch recover-branch ab1af&lt;/code&gt;. If there is no
reflog, I can run &lt;code&gt;git fsck --full&lt;/code&gt; to check the database for integrity and
get a list of objects that aren&amp;rsquo;t reacheable. The commit I&amp;rsquo;m looking for will
be labelled with &lt;code&gt;dangling commit&lt;/code&gt;, and I can create a branch pointing to it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Removing a file from every commit (e.g. accidentally committed large data
file): &lt;code&gt;git filter-branch --index-filter &#39;rm --ignore-unmatch --cached data.csv&#39; HEAD&lt;/code&gt;. This can take a long time. One way to speed things up is to
find the commit that added the file to the history and only filter downstream
from there. &lt;code&gt;git log --oneline --branches -- data.csv&lt;/code&gt; will list all commits
that contain the file from latest to earliest. If the file was added in
commit &lt;code&gt;a34s5&lt;/code&gt;, then I only want to rewrite commits &lt;code&gt;a34s5^..HEAD&lt;/code&gt;, which I
can substitute for &lt;code&gt;HEAD&lt;/code&gt; in the &lt;code&gt;filter-branch&lt;/code&gt; command. (In case I don&amp;rsquo;t
know the name of the large file I want to remove, see
&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;
for how to find it. Finally, as advised in relevant section
&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;, it&amp;rsquo;s best
to first do this on a separate branch to test the behaviour before running it
on &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;frequently-used-stuff-and-best-practices&#34;&gt;Frequently used stuff and best practices&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I&amp;rsquo;ve made changes pertaining to two different issues in the same file. How do
I commit them separately? Use the &lt;code&gt;--patch&lt;/code&gt; option either with &lt;code&gt;git add&lt;/code&gt; or
&lt;code&gt;git commit&lt;/code&gt;. This effectively opens the &lt;code&gt;patch&lt;/code&gt; option of the interactive
menue, which I could access using the &lt;code&gt;--interactive&lt;/code&gt; option.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I&amp;rsquo;ve started to work on an issue I decide I don&amp;rsquo;t want to work on yet but I
want to save that work. Just
&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stash&lt;/a&gt; the
work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I&amp;rsquo;m working on a topic branch and discover another issue I need to fix first.
What to do?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create local version of remote branch that automatically tracks remote branch
(if branch has unique remote counterpart): &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reset vs restore vs revert vs rebase (docs
&lt;a href=&#34;https://git-scm.com/docs/git#_reset_restore_and_revert&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;): &lt;code&gt;reset&lt;/code&gt; is
about updating your branch by adding or removing commits from the branch,
&lt;code&gt;restore&lt;/code&gt; is about unstading files from the index or undoing changes in the
working directory, &lt;code&gt;reset&lt;/code&gt; is about making new commits to undo changes made
by other commits,
&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Branching-Rebasing#_rebase_peril&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rebase&lt;/code&gt;&lt;/a&gt;,
like &lt;code&gt;merge&lt;/code&gt;, is a way to integrate work from two different branches. But
unlike &lt;code&gt;merge&lt;/code&gt;, which takes the endpoints of two branches and merges them
together, &lt;code&gt;rebase&lt;/code&gt; applies changes from the branch you merge onto the branch
you merge to in the order they happened and thus creates a linear history.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;understanding-reset&#34;&gt;Understanding reset&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Think of &lt;strong&gt;HEAD&lt;/strong&gt; as the last commit on the current branch (it&amp;rsquo;s a pointer to
the current branch which is a pointer to the last commit on that branch), the
&lt;strong&gt;index&lt;/strong&gt; as the proposed next commit, and the &lt;strong&gt;working directory&lt;/strong&gt; as a
sandbox. Think of all of them as collections of files, or file trees.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When I switch to a branch, Git makes HEAD point to the new branch ref,
populates the index with the snapshot of the last commit on that branch, and
copies the contents of the index into the working directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Changing a file updates it in the working directory, staging it updates the
version in the index with that of the working directory, and committing it
updates the version HEAD points to with that of the index.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git reset --soft HEAD~&lt;/code&gt; moves the branch that HEAD points to to the parent
of the last commit. The version of the file that HEAD points to now differs
from the versions in the index and the working directory, which still contain
the version of the last commit on the branch. Effectively, we&amp;rsquo;ve undone the
last commit. You could now make changes to the index and then commit them,
accomplishing the same as &lt;code&gt;git commit --amend&lt;/code&gt;. So, &lt;code&gt;--soft&lt;/code&gt; undoes &lt;code&gt;git commit&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git reset [--mixed] HEAD~&lt;/code&gt; moves the branch HEAD points to (just as &lt;code&gt;--soft&lt;/code&gt;
above) but then also updates index with the content of the snapshot HEAD now
points to. So, &lt;code&gt;--mixed&lt;/code&gt; undoes &lt;code&gt;git commit&lt;/code&gt; and &lt;code&gt;git add&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git reset --hard HEAD~&lt;/code&gt;, does what the above does, but then continues and
also updates the working directory with the content of the index. This
forcibly overwrites files, which, if they haven&amp;rsquo;t been committed (in which
case they can be recovered using the reflog), is unrecoverable. So, &lt;code&gt;--hard&lt;/code&gt;
undoes &lt;code&gt;git commit&lt;/code&gt;, &lt;code&gt;git add&lt;/code&gt;, and all changes made in the working
directory since the last commit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can undo multiple commits: to undo all commits since commit &lt;em&gt;9e5bf&lt;/em&gt;,
simply run &lt;code&gt;git reset &amp;lt;option&amp;gt; 9e5bf&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reset&lt;/code&gt; is also handy to squash commits together. To squash the last three
unpushed commits, use &lt;code&gt;git reset --soft HEAD~3&lt;/code&gt;. This moves the branch ref to
the great-grandparent of the latest commit. Because the index remains
unchanged, all changes committed after &lt;code&gt;HEAD~3&lt;/code&gt; now appear as staged and can
be committed in a single new commit.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;writing-good-commits&#34;&gt;Writing good commits&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Writing good commits (more
&lt;a href=&#34;https://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;No whitespace errors (&lt;code&gt;git diff --check&lt;/code&gt;, probs integrated in &lt;code&gt;fugitive&lt;/code&gt;
somehow).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each commit is a logically separate changeset.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Useful commit message using capitalisation and written in imperative style
(&amp;ldquo;Fix bug&amp;rdquo; instead of &amp;ldquo;Fixed bug&amp;rdquo; or &amp;ldquo;Fixes bug&amp;rdquo;, to be compatible with Git&amp;rsquo;s
auto generated messages) comprising a short summary (no longer than 50
characters so it fits on one line in log) followed by a blank line followed
by a motivation for the changes and a description of the contrast between old
and new behaviour.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;selecting-commits&#34;&gt;Selecting commits&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Short SHA-1 hashes: &lt;code&gt;git show d921&lt;/code&gt; shows the commit with abbreviated SHA-1 hash &lt;code&gt;d921&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Branch references: &lt;code&gt;git show iss3&lt;/code&gt; shows the commit on the tip of the branch
&lt;code&gt;iss3&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ancestry references: There are two different ways of ancestry selection which
I think of as &amp;ldquo;horizontal&amp;rdquo; and &amp;ldquo;vertical&amp;rdquo; selection. &lt;code&gt;^&lt;/code&gt; selects different
parents for merge commits: &lt;code&gt;git show d921^&lt;/code&gt; shows the first parent of the
merge commit. By default, this parent is from the branch from which the merge
was performed (frequently &lt;code&gt;main&lt;/code&gt;). &lt;code&gt;git show d921^2&lt;/code&gt; shows the second parent,
which is from the branch that was merged. I think of this as horizontal
ancestor selection.  Conversely, &lt;code&gt;~&lt;/code&gt; performs vertical ancestor selection in
that it iteratively selects the first parent a specified number of times.
&lt;code&gt;git show d921~&lt;/code&gt; shows the parent of &lt;code&gt;d921&lt;/code&gt;, &lt;code&gt;git show d921~2&lt;/code&gt; the parent of
the parent, &lt;code&gt;git show d921~3&lt;/code&gt; the parent of the parent of the parent, and so
on (the previous could also be written as &lt;code&gt;git show d921~~~&lt;/code&gt;). The two
syntaxes can be combined: &lt;code&gt;git show d921~2^2&lt;/code&gt; shows the second parent of the
grandparent of &lt;code&gt;d921&lt;/code&gt;, assuming the grandparent is a merge commit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Double dot: &lt;code&gt;git log main..iss3&lt;/code&gt; lists all commits that are reachable from
the &lt;code&gt;iss3&lt;/code&gt; but not the &lt;code&gt;main&lt;/code&gt; branch. Git substitues &lt;code&gt;HEAD&lt;/code&gt; if one side of
&lt;code&gt;..&lt;/code&gt; is empty, so to list local commits that aren&amp;rsquo;t yet on the remote, you
could do &lt;code&gt;git log origin/main..&lt;/code&gt;. Similarly, to select the last three
commits, use &lt;code&gt;HEAD~3..HEAD&lt;/code&gt;, which selects all commits reachable from &lt;code&gt;HEAD&lt;/code&gt;
but not &lt;code&gt;HEAD~3&lt;/code&gt;, which are commits &lt;code&gt;HEAD~2&lt;/code&gt;, &lt;code&gt;HEAD~&lt;/code&gt;, and &lt;code&gt;HEAD&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Triple dot: to list commits that occur either on &lt;code&gt;master&lt;/code&gt; or &lt;code&gt;iss3&lt;/code&gt; but not
both, I can do &lt;code&gt;git log master...iss3&lt;/code&gt;, and to get arrows to indicate whether
a commit is reachable from the right or left branch, &lt;code&gt;git log --left-right master...iss3&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;misc&#34;&gt;Misc.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;To search for commit message in log history: &lt;code&gt;git log --grep=&#39;regex&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gitignore&#34;&gt;&lt;code&gt;.gitignore&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The section on ignoring files in
&lt;a href=&#34;http://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt;
ProGit book chapter is excellently clear and provides very useful examples.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Iterators and generators</title>
      <link>https://fabiangunzinger.github.io/post/iterators-and-generators/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/iterators-and-generators/</guid>
      <description> &lt;iframe
       src=&#34;./iterators-and-generators.html&#34;
       width=&#34;90%&#34;
       height=&#34;4700px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Entropy</title>
      <link>https://fabiangunzinger.github.io/post/entropy/</link>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/entropy/</guid>
      <description> &lt;iframe
       src=&#34;./entropy.html&#34;
       width=&#34;90%&#34;
       height=&#34;3600px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm complexity analysis</title>
      <link>https://fabiangunzinger.github.io/post/algorithm-complexity-analysis/</link>
      <pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/algorithm-complexity-analysis/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The goal of algorithm analysis is to study the efficiency of an algorithm in
a language and machine-independent way.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The two most important tools for this are (1) the RAM model of computation
and (2) the asymptotic analysis of worst-case complexity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Random Access Machine (RAM) model of computation is a simple model of a
generic computer that is based on three main assumptions: (1) each simple
operation takes exactly one time step, (2) loops and subroutines are
considered composites of all simple operations they perform, and (3) memory
access from cache and RAM takes one time unit. None of these hold in
practice, but the model is extremely useful because it captures the essence
of algorithm behaviour while being very simple to work with.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Best, worst, and average-case complexity are functions defined by the
minimum, maximum, and average number of steps taken for any instance of size
&lt;em&gt;n&lt;/em&gt; of the input string. (Think about a graph with &lt;em&gt;n&lt;/em&gt; on the x-axis and &lt;em&gt;number
of steps&lt;/em&gt; on the y-axis, with number of steps for each instance of a problem
of size &lt;em&gt;n&lt;/em&gt; forming columns of dots with increasing variation as &lt;em&gt;n&lt;/em&gt; &amp;ndash; and
thus the number of possible instances &amp;ndash; increases. The three functions trace
the lowest, highest, and middle dots at each input size &lt;em&gt;n&lt;/em&gt;. See Fig 2.1 in
ADM.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using these functions to analyse algorithms is impractical, however, because
they are not smooth and require lots of detail about the algorithm and its
implementation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Big O notation ignores such details and focuses on the essentials to capture
the rate at which runtime (or space requirements) grow as a function of the
input size (the letter O is used because the growth rate of a function is
also called its order). In essence, this means only focusing on the higest
order term and ignoring constants (which depend on things like hardware and
programming language used to run the algorithm).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A function $f(n)$ is $O(g(n))$ if there exist constants $c$ and $n_0$ such
that $f(n) \leq cg(n)$ for any $n &amp;gt; n_0$.  Intuitively, this means that
$f(n)$ grows no faster than $cg(n)$ above a certain input size. For example:
$T(n) = 2n^2 + 3n$ is $O(n^2)$, since $5n^2 \geq 2n^2 + 3n$ for all positive
values of $n$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Amortised worse-case complexity takes into account that the running time of a
given operation in an algorithm may take a very long or a very short time
depending on the situation, and averages those different running times of the
operation in a sequence over that sequence. Adding an element to an array
that is dynamically resized takes $O(1)$ time until the array is full, when
the array needs to create a new array of twice its original size, copy all
elements over to the new array, and add the new element, which takes $O(n)$
time. Average worst-case complexity averages these runtimes to find that
pushing elements onto a dynamically resized array takes: $\frac{nO(1) +
O(n)}{n + 1} = O(1)$, constant time.
(&lt;a href=&#34;https://en.wikipedia.org/wiki/Amortized_analysis#Dynamic_array&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Source&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Is $2^{n+1} = O(2^n)$?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Is $(x + y)^2 = O(x^2 + y^2)$?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What&amp;rsquo;s the time complexity of $f(n) = min(n, 100)$?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The way to go is to start from the definition. The statement is true if
there is a $c$ and $n_0$ for which $c2^n \geq 2^{n+1}$ for $n &amp;gt; n_0$. The key
is to rewrite the right hand side to $c2^n \geq 2 \times 2^n$, which
makes it obvious that the statement holds whenever $c \geq 2$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Starting from the definition, the statement is true if there exist constants
$c$ and $n_0$ for which $c(x^2 + y^2) \geq (x + y)^2$ for $n &amp;gt; n_0$. Expanding
the right hand side, we get $c(x^2 + y^2) \geq x^2 + 2xy + y^2$.
Ignoring the middle term, the statement holds for $c = 1$; considering
only the middle term, we see that it is largest when $x = y$, in which
case the statement holds for $c = 2$. Thus, $3(x^2 + y^2) \geq (x +
y)^2$, so the statement is true.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I reflexively answered $n$. Thinking for a moment (an embarassingly long
one, admittedly), I realised that $n$ here refers not to the length of an
array but to a single number. So the operation is $O(1)$.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sources&#34;&gt;Sources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.algorist.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Steven Skiena, The Algorithm Design Manual (ADM)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://web.mit.edu/16.070/www/lecture/big_o.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT, Big O notation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Big_O_notation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wikipedia, Big O notation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Regex</title>
      <link>https://fabiangunzinger.github.io/post/regex/</link>
      <pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/regex/</guid>
      <description>&lt;p&gt;My regular expression cheatsheet, focused on the Python engine. A lot of
content is heavily based on (and often shamelessly copied from) the amazing
&lt;a href=&#34;https://www.rexegg.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RexEgg&lt;/a&gt; and
&lt;a href=&#34;https://www.regular-expressions.info&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Regular-Expressions.info&lt;/a&gt; sites.&lt;/p&gt;
&lt;h2 id=&#34;basics&#34;&gt;Basics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A regex is a text string that a regex engine uses to find text or positions
in a body of text, typically for the purposes of validating, finding,
replacing, and splitting.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To differentiate between the string that makes up the regex and the string
that is being searched, the former is often called &lt;em&gt;regex&lt;/em&gt; or &lt;em&gt;pattern&lt;/em&gt; and
the latter &lt;em&gt;string&lt;/em&gt; or &lt;em&gt;subject&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A (lexical) token is a string with an assigned and thus identified meaning
(more &lt;a href=&#34;https://en.wikipedia.org/wiki/Lexical_analysis#Token&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;). For
instance, the token &lt;code&gt;\w&lt;/code&gt; in a pattern stands for a word-character, and will
be replaced by that when the engine parses the string.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Python regex engine (and all other modern engines) is regex-directed: it
attempts all possible permutations of the regex at a character position of
the subject before moving on to the next character (which can involve lots of
backtracking). In contrast, text-directed engines visit each character in the
subject text only once. This makes them faster but also less powerful.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A regex engine is &lt;em&gt;eager&lt;/em&gt;: it scans alternatives in the regex from left to
right and returns the first possible match – &lt;code&gt;Jane|Janet&lt;/code&gt; would return
&lt;em&gt;Jane&lt;/em&gt; as a match in &lt;em&gt;Janet is tall&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;characters&#34;&gt;Characters&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There are four types of characters: literal characters (e.g. &lt;code&gt;a&lt;/code&gt;),
metacharacters (&lt;code&gt;^&lt;/code&gt;), non-printable characters (&lt;code&gt;\n&lt;/code&gt;), and shorthand
character classes (&lt;code&gt;\w&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Literal characters simply match themselves: the single literal character &lt;code&gt;a&lt;/code&gt;
matches the first &lt;em&gt;a&lt;/em&gt; in the string, the sequence of literal characters &lt;code&gt;cat&lt;/code&gt;
the first occurrence of &lt;em&gt;cat&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Metacharacters are the twelve punctuation characters from the ACSII
&lt;a href=&#34;https://www.asciitable.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;table&lt;/a&gt; that make regex work its magic: &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;,
&lt;code&gt;)&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;. To match metacharacters as
literals, escape them with a backslash, as in &lt;code&gt;1\+2=3&lt;/code&gt;. Exceptions are &lt;code&gt;{&lt;/code&gt;
and &lt;code&gt;}&lt;/code&gt;, which are only treated as metacharacters when part of a quantifier,
and &lt;code&gt;]&lt;/code&gt;, which only takes on special meaning when part of a character class).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-printable characters or formation marks are characters used to tell word
processors how text needs to look and do not appear in printed text.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shorthand character classes are tokens for certain common character classes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Non-printable characters&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Character&lt;/th&gt;
&lt;th&gt;Legend&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Carriage return&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Newline&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\r\n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Line-break on Windows&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Tab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\f&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Form-feed&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Shorthand character classes&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Character&lt;/th&gt;
&lt;th&gt;Legend&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Single digit, short for &lt;code&gt;[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Complement of &lt;code&gt;\d&lt;/code&gt;, short for &lt;code&gt;[^\d]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Word character, short for &lt;code&gt;[a-zA-Z\_]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Complement of &lt;code&gt;\w&lt;/code&gt;, short for &lt;code&gt;[^\w]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Whitespace character, short for &lt;code&gt;[\r\n\t\f\v ]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Complement of &lt;code&gt;\s&lt;/code&gt;, short for &lt;code&gt;[^\s]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Vertical whitespace, short for &lt;code&gt;[\n\f\r]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Complement of &lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;character-classes&#34;&gt;Character classes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Character classes tell the engine to match one of several characters.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Importantly: &lt;code&gt;[^a-z]u&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; mean &amp;ldquo;u not preceded by a lowercase
letter&amp;rdquo;, but &amp;ldquo;u preceded by &lt;em&gt;something&lt;/em&gt; that isn&amp;rsquo;t a lowercase letter&amp;rdquo;.
Hence, the pattern doesn&amp;rsquo;t match a &lt;em&gt;u&lt;/em&gt; at the beginning of a string. (In
contrast to the &lt;code&gt;.&lt;/code&gt;, the negated character class does match invisible line
breaks, though, so the above pattern would match the string &lt;em&gt;\nu&lt;/em&gt;.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Within a character class, metacharacters are literals with the exception of
&lt;em&gt;^&lt;/em&gt;, &lt;em&gt;-&lt;/em&gt;, &lt;em&gt;\&lt;/em&gt; and &lt;em&gt;]&lt;/em&gt; if they are used in places where they have special
meaning: ^ at the beginning, &lt;em&gt;-&lt;/em&gt; as part of a range, &lt;em&gt;]&lt;/em&gt; at the end, and &lt;em&gt;\&lt;/em&gt;
to escape another special character or to form a token (i.e. always), and &lt;em&gt;]&lt;/em&gt;
at the end. Hence, this regex matches them all as literals: &lt;code&gt;[]\\-^]&lt;/code&gt; (for
details on how to includ metacharacters indide character classes without
escaping them, see relevant section here
&lt;a href=&#34;https://www.regular-expressions.info/charclass.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;].&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Character classes examples&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Regex&lt;/th&gt;
&lt;th&gt;Match&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[ab]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;One of &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[^ab]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Any character that isn&amp;rsquo;t &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt; (incl. newline)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[\w\s]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;One word or whitespace character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[A-By-z1-2]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;One of &lt;em&gt;A&lt;/em&gt;, &lt;em&gt;B&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;, &lt;em&gt;z&lt;/em&gt;, &lt;em&gt;1&lt;/em&gt;, &lt;em&gt;2&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[ -~]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Any character in the printable section of the ASCII&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.asciitable.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;table&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Match &lt;em&gt;gray&lt;/em&gt; and &lt;em&gt;grey&lt;/em&gt; in &lt;em&gt;London is grey; New York, gray.&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match any character that is neither a digit nor a (hidden) line break
character.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What does &lt;code&gt;q[^u]&lt;/code&gt; match in &lt;em&gt;Iraq&lt;/em&gt; and &lt;em&gt;Iraq is a country&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How could we match any &lt;em&gt;q&lt;/em&gt; not followed by a &lt;em&gt;u&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Search for a literal * or +.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match any number greater than 10 made up of all the same digit (e.g. 222,
33, 5555).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In &lt;em&gt;b ab cb&lt;/em&gt;, match &lt;em&gt;b&lt;/em&gt; either at the beginning of the string or when
preceded by an &lt;em&gt;a&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What&amp;rsquo;s the difference between &lt;code&gt;[\D\S]&lt;/code&gt; and &lt;code&gt;[^\d\s]&lt;/code&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\bgr[ae]y\b&lt;/code&gt;. Discussion: need global flag on or use &lt;code&gt;findall()&lt;/code&gt; in Python
to match both words, otherwise I&amp;rsquo;ll just get the first one.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[\D\V]&lt;/code&gt;. Discussion: the negated character classs matches hidden line break
character by default (unlike the .), so need to explicitly exclude them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nothing and &lt;code&gt;q &lt;/code&gt;. Discussion: the regex means &amp;ldquo;q followed by something that
is not a u&amp;rdquo;, not &amp;ldquo;q not followed by a u&amp;rdquo;, so it requires something to follow
the q, and that something to not be a u. That something, which happens to be
a whitespace in the second string, is part of the match.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;q(?!u)&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[*+]&lt;/code&gt;. Discussion: these two characters have no special meaning within a
character class, so no need to escape them.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(\d)\1+&lt;/code&gt;. Discussion: need a capturing group for this (&lt;code&gt;[\d]{2,}&lt;/code&gt;, for
instance, would match any two digit number).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?:^|a)b&lt;/code&gt;. Discussion: &lt;code&gt;[a^]b&lt;/code&gt; would not work here, since &lt;code&gt;^&lt;/code&gt; is matched
literally inside a character class, so need a non-group with an alternation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[\D\S]&lt;/code&gt; matches a single character present inside the character class, so a
character that is either not a digit or not a space, which is every
character. &lt;code&gt;[^\d\s]&lt;/code&gt; matches a single character that is not present inside
the character class, so that is neither a digit nor a space, which is all
letters.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;quantifiers&#34;&gt;Quantifiers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A quantifier tells the engine to match the immediately preceding character,
token, or subexpression (e.g. &lt;code&gt;(a|b)&lt;/code&gt;) a certain number of times.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nomenclature:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Greedy&lt;/em&gt; quantifiers: the default property of quantifiers to match as many
characters as possible and thus return the longest possible match. E.g. &lt;code&gt;\d+&lt;/code&gt;
matches &lt;em&gt;123&lt;/em&gt; (not &lt;em&gt;1&lt;/em&gt; or &lt;em&gt;12&lt;/em&gt;) against &lt;em&gt;123&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Docile&lt;/em&gt; quantifiers: the property of a greedy quantifier to backtrack and
give up characters to try the rest of the pattern to match. This is the
property behind the &amp;ldquo;possible&amp;rdquo; in the above definition: a greedy quantifier
matches as many characters of the quantified token as it can for the overall
pattern to match. E.g. &lt;code&gt;.*c&lt;/code&gt; will run all the way to the end of the string &lt;em&gt;abc&lt;/em&gt;,
fail to match the &lt;em&gt;c&lt;/em&gt; in the pattern, backtrack and give up the &lt;em&gt;c&lt;/em&gt; character
matched by dot-star, try again to match &lt;em&gt;c&lt;/em&gt;, succeed, and return.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Lazy&lt;/em&gt; quantifiers: the property of a quantifier to match as few characters
as necessary and thus return the shortest possible match. Quantifiers are
made lazy by appending &lt;code&gt;?&lt;/code&gt;. Example: &lt;code&gt;\d+?&lt;/code&gt; matches &lt;em&gt;1&lt;/em&gt; against &lt;em&gt;123&lt;/em&gt;.  Lazy
quantifiers are expensive: laziness and helpfulness make the engine advance
from the beginning to the end of a string character by character, at each
step expanding the match by including the next character, advancing and
attempting to match the rest of the pattern, fail, backtrack, and repeat
until it finds a match or reaches the end of the string.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Helpful&lt;/em&gt; quantifiers: the property of a lazy quantifier to backtrack and
match additional characters of the quantified token in the attempt to match
the rest of the pattern. This is the property behind the &amp;ldquo;necessary&amp;rdquo; in the
above definition: a lazy quantifier matches as few characters as it can for
the overall pattern to match. E.g. &lt;code&gt;a*?b&lt;/code&gt; will first match zero &lt;em&gt;a&lt;/em&gt;s against
&lt;code&gt;aab&lt;/code&gt;, advance and try to match the &lt;em&gt;b&lt;/em&gt;, fail, backtrack and match the first
&lt;em&gt;a&lt;/em&gt;, advance and try to match the &lt;em&gt;b&lt;/em&gt;, fail again, backtrack and match the
second &lt;em&gt;a&lt;/em&gt;, advance and try to match the &lt;em&gt;b&lt;/em&gt;, succeed and return.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Possessive&lt;/em&gt; quantifiers: an optional property of a quantifier that prevents
it from giving up previously matched characters if the rest of the pattern
doesn&amp;rsquo;t match (i.e. it makes the quantifier non-docile). We can make a
quantifier possessive by appending a &lt;code&gt;+&lt;/code&gt;. Example: &lt;code&gt;a++&lt;/code&gt; greedily matches as
many &lt;em&gt;a&lt;/em&gt;s as it can and never gives any of them back.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quantifiers and modifiers:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Token&lt;/th&gt;
&lt;th&gt;Legend&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match zero or once&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match zero or more&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match once or more&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match n times&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Match between n and m times, n defaults to 0, m to infinity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Make quantifier lazy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{quantifier}+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Make quantifier possessive&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Matches in string &lt;em&gt;a5aa5&lt;/em&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Pattern&lt;/th&gt;
&lt;th&gt;Matches in GLOBAL mode (total: list)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;3: a, a, a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2: a, aa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a+?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;3: a, a, a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;5: a, &amp;lsquo;&amp;rsquo;, aa, &amp;lsquo;&amp;rsquo;, &#39;&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a*?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;6: &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &#39;&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;6: a, &amp;lsquo;&amp;rsquo;, a, a, &amp;lsquo;&amp;rsquo;, &#39;&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a??&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;6: &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &#39;&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a{2}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1: aa&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a{,2}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;5: a, &amp;lsquo;&amp;rsquo;, aa, &amp;lsquo;&amp;rsquo;, &#39;&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a{,2}?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;6: &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &amp;lsquo;&amp;rsquo;, &#39;&#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a{1,}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2: a, aa&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;a href=&#34;https://www.rexegg.com/regex-quantifiers.html#greedytrap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;greedy trap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the string &lt;em&gt;{start} Mary {end} had a {start} little lamb {end}&lt;/em&gt;, match all
tokens that start with &lt;em&gt;{start}&lt;/em&gt; and end with &lt;em&gt;{end}&lt;/em&gt;. The naive solution is,
&lt;code&gt;{start}.*{end}&lt;/code&gt;, which will run over the first &lt;em&gt;{end}&lt;/em&gt; to match entire string
since &lt;code&gt;.*&lt;/code&gt; is greedy &amp;ndash; this is the greedy trap.&lt;/p&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Lazy quantifier&lt;/em&gt;: &lt;code&gt;{start}.*?{end}&lt;/code&gt;. Computationally inefficient as it
proceeds character-by-character left to right with successive backtracking.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Negated character class&lt;/em&gt;: &lt;code&gt;{start}[^{]*{end}&lt;/code&gt;. An example of the contrast
principle, but works only if &lt;em&gt;{&lt;/em&gt; never appears inside the delimiters.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Tempered greedy token&lt;/em&gt;: &lt;code&gt;{start}(?:(?!{end}).)*{end}&lt;/code&gt;. Ensures that the &lt;code&gt;.&lt;/code&gt;
never matches the opening bracket of &lt;em&gt;{end}&lt;/em&gt;, thus making sure we don&amp;rsquo;t run
over an end token. This allows the &lt;em&gt;{&lt;/em&gt; to occur inside the string. Because it
requires a lookahead at east step, it is no more efficient than the lazy
quantifier solution in this case, though.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Explicit greedy alternation&lt;/em&gt;: &lt;code&gt;{start}(?:[^{]|{(?!end}))*{end}&lt;/code&gt;. This is an
example of the &lt;em&gt;say what you want&lt;/em&gt; principle: we either want to match
characters that aren&amp;rsquo;t an opening brace or an opening brace not followed by
&lt;em&gt;end}&lt;/em&gt;. This requires a lookahead only in the rare case where we find an
opening brace rather than at each step and is thus more efficient than the
tempered greedy token or lazy quantifier solutions. We can optimise the
pattern in two ways: avoiding exiting the alternation at each step and
instead matching entire sequences of non-brace characters, and avoiding
backtracking if the &lt;em&gt;{end}&lt;/em&gt; token at the end of the pattern fails to match,
which will never be useful. We can achieve these optimisations by either
using possessive quantifiers &lt;code&gt;{start}(?:[^{]++|{(?!end}))*+{end}&lt;/code&gt; (&lt;code&gt;++&lt;/code&gt; is
required to avoid an explosive quantifier) or atomic groups
&lt;code&gt;{start}(?&amp;gt;(?:(?&amp;gt;[^{]+)|{(?!end}))*){end}&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;a href=&#34;https://www.rexegg.com/regex-quantifiers.html#lazytrap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;lazy trap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;{start} Mary {end}00A {start} little {lamb {end}01B&lt;/em&gt;, match all
tokens that start with &lt;em&gt;{start}&lt;/em&gt; and end with &lt;em&gt;{end}&lt;/em&gt;, followed by a sequence
of digits and a &lt;em&gt;b&lt;/em&gt;, which are to be included in the match. The naive solution,
&lt;code&gt;{start}.*?{end}\d+B&lt;/code&gt; doesn&amp;rsquo;t work, as it runs over the first &lt;em&gt;{end}&lt;/em&gt; to match
the entire string (why?) &amp;ndash; this is the lazy trap.&lt;/p&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Atomic groups&lt;/em&gt;: &lt;code&gt;{start}(?&amp;gt;.*{end}\d+B)&lt;/code&gt; prevents the engine from
backtracking once &lt;em&gt;B&lt;/em&gt; can&amp;rsquo;t be matched after the first &lt;em&gt;{end}00&lt;/em&gt; and thus
prevents the &lt;code&gt;.*&lt;/code&gt; to expand further.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Negated character class&lt;/em&gt;: &lt;code&gt;{start}[^{]*{end}\d+B&lt;/code&gt; works, but with the usual
limitation that it requires the assumption that there are no &lt;em&gt;{&lt;/em&gt; between the
start and end tokens.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Tempered greedy token&lt;/em&gt;: &lt;code&gt;{start}(?:(?!{end}).)*{end}\d+B&lt;/code&gt; works just as in
the greedy trap solution above.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Explicit greedy alternation&lt;/em&gt;: &lt;code&gt;{start}(?:[^{]++|{(?!end}))*+{end}\d+B&lt;/code&gt; also
works just as in the greedy trap solution above.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;What does the quantifier apply to in the following patterns: &lt;code&gt;\w+&lt;/code&gt;,
&lt;code&gt;carrots?&lt;/code&gt;, &lt;code&gt;(a|b)*&lt;/code&gt;, &lt;code&gt;\Qab\E+&lt;/code&gt;, &lt;code&gt;(?:(?!{end}).)*&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What&amp;rsquo;s the simplest way to match &lt;em&gt;color&lt;/em&gt; or &lt;em&gt;colour&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Why is &lt;code&gt;&amp;lt;.+?&amp;gt;&lt;/code&gt; not an ideal solution?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match digits of length 2, 4, or 6.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the above solution matches &lt;em&gt;123456&lt;/em&gt;, what does &lt;code&gt;\1&lt;/code&gt; contain?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adapt the regex from above so it always captures the full match.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Does &lt;code&gt;A+.&lt;/code&gt; match &lt;em&gt;AAA&lt;/em&gt;? What about &lt;code&gt;A++.&lt;/code&gt;? Explain.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write a regex that matches strings of digits that end with an &lt;em&gt;a&lt;/em&gt;, such as
&lt;em&gt;123a&lt;/em&gt;, with maximal efficiency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explain, step-by-step, what happens if we try to match &lt;em&gt;aaac&lt;/em&gt; with the
pattern &lt;code&gt;^(a+)*b&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In &lt;em&gt;{start} Mary {end} had a {start} little lamb {end}&lt;/em&gt;, match all tokens
that start with &lt;em&gt;{start}&lt;/em&gt; and end with &lt;em&gt;{end}&lt;/em&gt;, but only if the string
doesn&amp;rsquo;t contain &lt;em&gt;{mid}&lt;/em&gt; or &lt;em&gt;{restart}&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;(a|b)&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;colou?r&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Because by default, quantifiers are greedy and so &lt;code&gt;.+&lt;/code&gt; matches as many
characters as it can, initially racing all the way to the end of the string,
then failing to match &lt;code&gt;&amp;gt;&lt;/code&gt;, then backtracking once, trying again, succeeding
and (eagerly) returning. To only match the opening token, use &lt;code&gt;&amp;lt;[^&amp;gt;]+&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Because it&amp;rsquo;s computationally expensive.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(\d\d){1,3}&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;56.&lt;/em&gt; Explanation: the backreference always contains the content of the last
iteration of the group, so &lt;code&gt;(\d\d){3}&lt;/code&gt; captures the same text as
&lt;code&gt;\d\d\d\d(\d\d).&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;((?:\d\d){1,3})&lt;/code&gt;. Explanation: wraps the full match in a capturing
group and turns the subexpression we don&amp;rsquo;t want to capture in a
non-capturing group.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solution: yes and no. Explanation: the first pattern first greedily matches
all three &lt;em&gt;A&lt;/em&gt;s in the string, then advances in the pattern and fails to
match the dot, backtracks and gives up the last matched &lt;em&gt;A&lt;/em&gt;, advances again,
succeeds in matching the dot with the last &lt;em&gt;A&lt;/em&gt; in the string, and returns.
The second pattern also fails to match the dot at first, but because it is
possesive it doesn&amp;rsquo;t backtrack and give up the last-matched &lt;em&gt;A&lt;/em&gt; and so
simply fails.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solution: &lt;code&gt;\d++a&lt;/code&gt;. A possessive quantifier improves efficiency because &lt;code&gt;\d&lt;/code&gt;
and &lt;em&gt;a&lt;/em&gt; are mutually exclusive, so there is never a good reason for the
engine to give up characters and backtrack as there cannot be an &lt;em&gt;a&lt;/em&gt; inside
the (greedily) matched sequence of digits.  Hence, if the last matched digit
isn&amp;rsquo;t followed by an &lt;em&gt;a&lt;/em&gt; we want the engine to fail immediately. This is
what the possessive quantifier does. If we know that the regex can only
match at the beginning of the string, then prepending the &lt;code&gt;\A&lt;/code&gt; anchor
improves efficiency by failing when we can&amp;rsquo;t match the pattern starting from
the first digit in the string instead of stepping through all remaining
digits, which can&amp;rsquo;t possibly match.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This is an example of an &lt;a href=&#34;https://www.rexegg.com/regex-explosive-quantifiers.html#example&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;explosive
quantifier&lt;/a&gt;:
a case where the number of combinations the engine attempts to match by
successive backtracking increases exponentially in the length of the
string. What happens? &lt;code&gt;a+&lt;/code&gt; matches &lt;em&gt;aaa&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt;, nothing, and the &lt;code&gt;b&lt;/code&gt; fails
to match against &lt;em&gt;c&lt;/em&gt;. The engine backtracks and makes &lt;code&gt;a+&lt;/code&gt; give up the last
matched character, so this now matches &lt;em&gt;aa&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; can now repeat the
previous pattern &amp;ndash; remember, it matches the pattern &lt;code&gt;a+&lt;/code&gt;, not the match
&lt;em&gt;aa&lt;/em&gt; &amp;ndash; and matches &lt;em&gt;a&lt;/em&gt;, but &lt;code&gt;b&lt;/code&gt; again fails to match against &lt;em&gt;c&lt;/em&gt;. In the
next backtrack, the &lt;code&gt;a+&lt;/code&gt; matched by &lt;code&gt;*&lt;/code&gt; gives up the last matched
character, the third &lt;em&gt;a&lt;/em&gt;, so the first &lt;code&gt;a+&lt;/code&gt; still matches &lt;em&gt;aa&lt;/em&gt;, the second
&lt;code&gt;a+&lt;/code&gt;, nothing, and &lt;code&gt;b&lt;/code&gt; fails to match. This keeps going. RexEgg has a
useful
&lt;a href=&#34;https://www.rexegg.com/regex-explosive-quantifiers.html#combinations&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;table&lt;/a&gt;
to show the match of different repetitions of the &lt;code&gt;a+&lt;/code&gt; component:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;a+&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;a+&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;a+&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;aaa&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;aa&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;aa&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;aa&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;&lt;code&gt;{start}(?:(?!{mid})(?!{restart}).)*?{end}&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;anchors-and-word-boundaries&#34;&gt;Anchors and word boundaries&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Anchors assert that the engine&amp;rsquo;s current position in a string matches a
certain position like the beginning or the end, while boundaries make
assertions about what can and cannot be matched to the left and the right of
the current position.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; matches the position just before the first character of the string, so
&lt;code&gt;^a&lt;/code&gt; means &amp;ldquo;position just before start of string followed by a&amp;rdquo;. Similarly,
&lt;code&gt;$&lt;/code&gt; matches position just after the last character in the string, and &lt;code&gt;c$&lt;/code&gt;
means &amp;ldquo;c followed by the position just after the end of the string&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiline mode makes &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match positions just before first and just
after last character of the line rather than the entire string.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt; subtlety: if the very last character in a line is a line break, &lt;code&gt;$&lt;/code&gt;
matches both just before it and at the very end just after it (i.e. &lt;code&gt;\d+$&lt;/code&gt;
matches &lt;em&gt;123&lt;/em&gt; in both &lt;em&gt;123&lt;/em&gt; and &lt;em&gt;123\n&lt;/em&gt;. This is true regardless of whether
multiline mode is turned on. (If there are multiple line breaks at the end,
the above behaviour only applies to the final one, so &lt;code&gt;\d+$&lt;/code&gt; would not match
&lt;em&gt;123&lt;/em&gt; in &lt;em&gt;123\n\n&lt;/em&gt;.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\z&lt;/code&gt; vs &lt;code&gt;\Z:&lt;/code&gt; similar to the above point, in most engines &lt;code&gt;\z&lt;/code&gt; matches only
at the very end of a string (i.e. after the linebreak if there is one), while
&lt;code&gt;\Z&lt;/code&gt; is the flexible end-of-string anchor that can match before and after the
linebreak at the end of a string. In Python, &lt;code&gt;\Z&lt;/code&gt; behaves like &lt;code&gt;\z,&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt;
doesn&amp;rsquo;t exist.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Character&lt;/th&gt;
&lt;th&gt;Legend&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches beginning of string or line (in multiline mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches end of string or line (in multiline mode)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches only beginning of string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\Z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches only very end of string (same as &lt;code&gt;\z&lt;/code&gt; in most other engines)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches if one side is a word character and the other isn&amp;rsquo;t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Matches wherever &lt;code&gt;\b&lt;/code&gt; doesn&amp;rsquo;t&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Match &lt;em&gt;cat&lt;/em&gt; a) on its own or at the end of a word (e.g. &lt;em&gt;tombcat&lt;/em&gt;), b) on
its own or at the beginning of a word (e.g. &lt;em&gt;catwalk&lt;/em&gt;), c) only on its own, d)
fully surrounded by word characters, e) fully surrounded or at the beginning or
the end but not on its own.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match &lt;em&gt;Jane&lt;/em&gt; or &lt;em&gt;Janet&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a boundary that detects the edge between a letter and a non-letter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the string &lt;em&gt;0# 1 #2 #3# 4# #5&lt;/em&gt;, match digits where each side is either a
hash or the edge of the string (i.e. 0, 3, 5).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Within the vernacular of RexEgg, explain the difference between an anchor, a
boundary, and a delimiter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Implementing &lt;code&gt;^&lt;/code&gt; manually: write patterns that match &lt;em&gt;a&lt;/em&gt; at the beginning of
a) the string, b) each line, c) line three and beyond.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;a) &lt;code&gt;cat\b&lt;/code&gt; b) &lt;code&gt;\bcat&lt;/code&gt;, c) &lt;code&gt;\bcat\b&lt;/code&gt;, d) &lt;code&gt;\Bcat\B&lt;/code&gt;, e) &lt;code&gt;\Bcat|cat\B&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\bJanet?\b&lt;/code&gt; or &lt;code&gt;\b(Jane|Janet)\b&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?i)(?&amp;lt;![a-z])(?=[a-z])|(?&amp;lt;=[a-z])(?![a-z])&lt;/code&gt;. Discussion: RexEgg uses the
following
&lt;a href=&#34;https://www.rexegg.com/regex-boundaries.html#real-word-boundary&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;alternative&lt;/a&gt;:
&lt;code&gt;(?i)(?&amp;lt;=^|[^a-z])(?=[a-z])|(?&amp;lt;=[a-z])(?=$|[^a-z])&lt;/code&gt;.  The two versions are
the same, but I find the first version easier to read.  Using negated
character classes requires that we explicitly allow for &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;, since
otherwise the regex engine tries to match a character that isn&amp;rsquo;t a letter
and &lt;a href=&#34;https://www.regular-expressions.info/charclass.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fails&lt;/a&gt;. Using
negative lookarounds solves this, since these succeed whenever the engine
cannot match a lowercase letter in the specified position in the string,
which is also true if there is a beginning or end of line character in that
&lt;a href=&#34;https://www.regular-expressions.info/lookaround.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;position&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Using capturing group: &lt;code&gt;(?:^|#)(\d)(?:$|#)&lt;/code&gt;. Using lookarounds:
&lt;code&gt;(?&amp;lt;=[#^])\d(?=[#$])&lt;/code&gt;. Using &lt;a href=&#34;https://www.rexegg.com/regex-boundaries.html#double-negative-delimiter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;double negative
delimiter&lt;/a&gt;:
&lt;code&gt;(?&amp;lt;![^#])\d(?![^#])&lt;/code&gt;. The lookbehind asserts: &amp;ldquo;what immediately precedes
the current position is not a character that is not a hash&amp;rdquo;, which, turning
the logic around, is equivalent to &amp;ldquo;either not a character or a hash&amp;rdquo;. The
logic of the lookahead is similar. This is thus a clever way to match either
a particular (set of) characters or the edge of a string. (This works for
single-line strings only, as in multiline strings, &lt;code&gt;\n&lt;/code&gt; characters at the
beginning and end are characters that aren&amp;rsquo;t a hash.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;They all make assertions about the current position in the string: &lt;em&gt;anchors&lt;/em&gt;
assert that what immediately precedes or follows the furrent position is a
particular position in the string such as the beginning of the string or the
end of the line; &lt;em&gt;boundaries&lt;/em&gt; make assertions about that is immediately to
the left and the right of the current position such as a non-word character
on the left and a word character to the right; and &lt;em&gt;delimiters&lt;/em&gt; are similar
to bouldaries but only look on one side, asserting, for instance, that what
immediately precedes the current position is not a character. These lines
are &lt;a href=&#34;https://www.rexegg.com/regex-anchors.html#semantics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blurry&lt;/a&gt;, however.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a) &lt;code&gt;(?s)(?&amp;lt;!.)a&lt;/code&gt;, b) &lt;code&gt;(?&amp;lt;!.)a&lt;/code&gt;, c) &lt;code&gt;(?&amp;lt;\n.*\n)a&lt;/code&gt;. Discussion: in a) we need
DOTALL mode so that &lt;code&gt;.&lt;/code&gt; matches linebreaks to prevent the engine from
matching at the beginning of new lines, in b) we want the engine to match at
the beginning of new lines and thus omit DOTALL mode, for c) we need the
flexible-width lookbehinds from the &lt;code&gt;regex&lt;/code&gt; module.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;alternation&#34;&gt;Alternation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Character classes like &lt;code&gt;[ab]&lt;/code&gt; tell the regex engine to match a single
character out of several possible characters; alternations like &lt;code&gt;(Jane|Bob)&lt;/code&gt;,
to match a single regex out of several possible regexes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;What do &lt;code&gt;cat|dog&lt;/code&gt;, &lt;code&gt;\bcat|dog\b&lt;/code&gt;, and &lt;code&gt;\b(cat|dog)\b&lt;/code&gt; match?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find all occurrences of &lt;em&gt;Get&lt;/em&gt;, &lt;em&gt;GetValue&lt;/em&gt;, &lt;em&gt;Set&lt;/em&gt;, &lt;em&gt;SetValue&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The first matches any occurrences of the strings (e.g. &lt;em&gt;cat&lt;/em&gt; in
&lt;em&gt;uncategorised&lt;/em&gt; or &lt;em&gt;dog&lt;/em&gt; in &lt;em&gt;dogmatic&lt;/em&gt;), the second matches words that begin
with &lt;em&gt;cat&lt;/em&gt; and words that end with &lt;em&gt;dog&lt;/em&gt;, the third &lt;em&gt;cat&lt;/em&gt; and &lt;em&gt;dog&lt;/em&gt; on their
own.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(Get|Set)(Value)?&lt;/code&gt; is reasonably concise and easy to read. It works because
&lt;code&gt;?&lt;/code&gt; is greedy, which means it attempts to match &lt;em&gt;GetValue&lt;/em&gt; before &lt;em&gt;Get&lt;/em&gt;,
assuring that it never matches &lt;em&gt;Get&lt;/em&gt; in &lt;em&gt;GetValue&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;groups&#34;&gt;Groups&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Grouping part of a regex together can be useful to apply a quantifier to a
group of tokens, to restrict alternation to a part of the pattern, and to use
backreference.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There are three types of groups: capturing, non-capturing, and atomic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Capturing groups have three main uses: 1) reuse matches using backreferences,
2) use captured text as replacement text in search and replace, 3) use
captured parts in applications. Capturing groups get numbered from left to
right, and, if they have a quantifier, return the value of the last captured
iteration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-capturing groups allow for avoiding the capturing overhead when grouping
is needed but capturing isn&amp;rsquo;t.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Atomic groups become solid as a block once the engine leaves the group and
thus prevent the engine from backtracking into the group even if the rest of
the expression fails to match. This can be useful to avoid unwanted
backtracking when groups contain quantifiers or alternation. In the former
case, we could also use possessive quantifiers.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Character&lt;/th&gt;
&lt;th&gt;Legend&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Capturing group&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\1, ..., \99&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Backreferences to capturing groups&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?:regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Non-capturing group&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?P&amp;lt;name&amp;gt;regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Named capturing group in &lt;code&gt;re&lt;/code&gt; module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?P=name)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Backreference to named capturing group in &lt;code&gt;re&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;name&amp;gt;regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Named capturing group in &lt;code&gt;regex&lt;/code&gt; module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\g&amp;lt;name&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Backreference to named capturing group in &lt;code&gt;regex&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&amp;gt;regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Atomic group&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Find magical dates, dates where the two final year digits are identical to
the day and month digits (e.g. &lt;em&gt;2008-08-08&lt;/em&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Capture day, month, year in &lt;em&gt;dd-mm-yyyy&lt;/em&gt; dates.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Name the groups in the above example (use the &lt;code&gt;regex&lt;/code&gt; module).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Search for magic dates using a named group.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What&amp;rsquo;s the difference between the result returned from &lt;code&gt;(\w+)&lt;/code&gt; and &lt;code&gt;(\w)+&lt;/code&gt;
when matching the string &lt;em&gt;Hello&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find all patterns of the form &lt;em&gt;sum of digits = reversed sum of digits&lt;/em&gt; (e.g.
&lt;em&gt;22 + 333 = 333 + 22&lt;/em&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find all cases of repeated words in &lt;em&gt;Hello world world this was some great
greatness, wasn&amp;rsquo;t wasn&amp;rsquo;t it?&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A typical URL has the form &lt;code&gt;&amp;lt;protocol&amp;gt;://&amp;lt;host&amp;gt;/&amp;lt;path&amp;gt;&lt;/code&gt; (e.g.
&lt;code&gt;https://www.abc.com/index.html&lt;/code&gt;). Write a regex that captures the host and,
if available, the path but not the protocol, yet validates that the protocol
is either &lt;em&gt;http&lt;/em&gt; or &lt;em&gt;https&lt;/em&gt; (inspired by
&lt;a href=&#34;https://stackoverflow.com/a/3513858&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; SO post).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write a regex similar to the previous one, but now validate that the host is
one of &lt;em&gt;http&lt;/em&gt;, &lt;em&gt;https&lt;/em&gt;, or &lt;em&gt;s3&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In strings containing &lt;em&gt;Bob says: word&lt;/em&gt;, group the entire regex but only
capture the word Bob says (e.g. in &lt;em&gt;Bob says: hello&lt;/em&gt; capture &lt;em&gt;hello&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In strings containing tokens of the form &lt;em&gt;upNUMBER&lt;/em&gt; or &lt;em&gt;downNUMBER&lt;/em&gt;,
capture the tokens.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Does &lt;code&gt;(?&amp;gt;A|.B)C&lt;/code&gt; match against &lt;em&gt;ABC&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Does &lt;code&gt;(?&amp;gt;a+)[a-z]c&lt;/code&gt; match against &lt;em&gt;aac&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\d\d(\d\d)-\1-\1&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(\d{2})-(\d{2})-(\d{4})&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?&amp;lt;day&amp;gt;\d{2})-(?&amp;lt;month&amp;gt;\d{2})-(?&amp;lt;year&amp;gt;\d{4})&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\d\d(?&amp;lt;yy&amp;gt;\d\d)-\g&amp;lt;yy&amp;gt;-\g&amp;lt;yy&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(\w+)&lt;/code&gt; returns &lt;em&gt;Hello&lt;/em&gt;; &lt;code&gt;(\w)+&lt;/code&gt;, &lt;em&gt;o&lt;/em&gt;. Discussion: a capturing group with a
quantifier contains the last matched iteration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(\d+) \+ (\d+) = \2 \+ \1&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(\b[\w&#39;]++\b) \b\1\b&lt;/code&gt;. Discussion: If we don&amp;rsquo;t use word boundaries we&amp;rsquo;d
also match the &lt;em&gt;s&lt;/em&gt;s in &lt;em&gt;was some&lt;/em&gt; and &lt;em&gt;great&lt;/em&gt; in &lt;em&gt;great greatness&lt;/em&gt;, and
without allowing for &lt;em&gt;&#39;&lt;/em&gt; we&amp;rsquo;d miss the repetition of &lt;em&gt;wasn&amp;rsquo;t&lt;/em&gt;. Adding a
possessive quantifier avoids unnecessary backtracking, which we never want
here, as we always want to capture full words only.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;https?://([^/\s]+)(\S+)?&lt;/code&gt;. Discussion: The &lt;code&gt;\s&lt;/code&gt; inside the character class
ensures the match doesn&amp;rsquo;t include characters that follow the url. We could
include &lt;code&gt;/&lt;/code&gt; in the second capturing group to be explicit that what
immediately follows the host starts with a forward slash, but it&amp;rsquo;s redundant
because the first group matches up to a space character or a forward slash
and the second group only matches if what follows directly thereafter is not
a space, character, which implies that the second group can only return a
match if its content starts with a forward slash.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?:https?|s3)://([^/\s]+)(\S+)?&lt;/code&gt;. Discussion: remind yourself why we cannot
just add an alternation without a non-capturing group.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(?:Bob says: (\w+))&lt;/code&gt;. Discussion: a contrived use of a capturing group
within a non-capturing group.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;((?:up|down)\d+)&lt;/code&gt;. Discussion: an example of capturing the content of a
non-capturing group by wrapping it in a capturing group.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No, the engine will match &lt;em&gt;A&lt;/em&gt; at beginning of the string and then fail to
match &lt;em&gt;C&lt;/em&gt;. Because the group is atomic, it won&amp;rsquo;t backtrack into the group
to match &lt;em&gt;.B&lt;/em&gt; and fail.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No. Similarly to above, the engine greedily matches both &lt;em&gt;a&lt;/em&gt;s, then the
character class matches &lt;em&gt;c&lt;/em&gt;, and the final &lt;em&gt;c&lt;/em&gt; in the regex fails to match.
Because the grouped expression is atomic, the engine doesn&amp;rsquo;t backtrack and
give up one of the two matched &lt;em&gt;a&lt;/em&gt;s.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;lookarounds&#34;&gt;Lookarounds&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Just like anchors, lookarounds are zero-length assertions that determine
whether a match is possible in a given location. The difference to anchors is
that lookarounds match characters rather than positions in the string, but
then give up the matched strings and simply return whether or not they
existed. The last step is what makes them zero-length matches, which means
the regex engine stays at the current position in the subject string rather
than advancing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lookaheads can contain any regex, lookbehinds can&amp;rsquo;t: they have to be
fixed-length expressions (i.e. literalse, character escapes, character
classes, or alternations where all alternatives are of equal length, but not
quantifiers or backreferences). This is because the regex engine steps back by
the length of the lookbehind to evaluate matches, and thus needs to know said
length. (Actually, the &lt;code&gt;regex&lt;/code&gt; module can handle flexible-width lookbehinds.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As a result of the above, capturing groups can only be used in lookaheads.
To use them, simply wrap the regex in parentheses.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lookarounds don&amp;rsquo;t look way into the distance: &lt;code&gt;(?=A)&lt;/code&gt; doesn&amp;rsquo;t mean &amp;ldquo;there is
an A somewhere to the right&amp;rdquo;, it asserts that what immediately follows is an
A. To look into the distance, you have to include
&lt;a href=&#34;https://www.rexegg.com/regex-lookarounds.html#stand_their_ground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;binoculars&amp;rdquo;&lt;/a&gt;
such as &lt;code&gt;.*&lt;/code&gt; or, if possible, more specific tokens.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Lookaround&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;What it does&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?=foo)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Lookahead&lt;/td&gt;
&lt;td&gt;Asserts that what immediately follows the current position in foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;=foo)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Lookbehind&lt;/td&gt;
&lt;td&gt;Asserts that what immediately precedes the current position is foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?!foo)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Negative\nLookahead&lt;/td&gt;
&lt;td&gt;Asserts that what immediately follows the current position is not foo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;!foo)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Negative\nLookbehind&lt;/td&gt;
&lt;td&gt;Asserts that what immediately precedes the current position is not foo&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Practice:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Write &lt;code&gt;\A&lt;/code&gt; using a lookaround. Solution if DOTALL mode is on: &lt;code&gt;(?&amp;lt;!.)&lt;/code&gt;
Solution if DOTALL mode is off: &lt;code&gt;(?&amp;lt;![\D\d])&lt;/code&gt;. Discussion: If DOTALL mode is
on an &lt;code&gt;.&lt;/code&gt; matches every character including linebreaks, the first lookbehind
asserts that what precedes the current position is not any character, so the
position must be the beginning of the string. &lt;code&gt;[\D\d]&lt;/code&gt; matches any character
that is a digit or not a digit, which is any character, and thus achieves the
same thing if DOTALL mode is off.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match e if followed either by aa or bb. Solution: e(?=([ab])\1).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What does &lt;code&gt;q(?=u)i&lt;/code&gt; match in &amp;ldquo;quit&amp;rdquo;? Solution: nothing. The regex tries to
match a u and an i at the same position.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match words that don&amp;rsquo;t end in s. Solution: &lt;code&gt;\b\w+(?&amp;lt;!s)\b.&lt;/code&gt; Explanation:
approach matches words and, at the end postition, looks back to check that
the character that immediately precedes the current position, which is the
last character, is not an &amp;ldquo;s&amp;rdquo;. Needs word boundaries to prevent engine from
backtracking and match word without final s.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explain why &lt;code&gt;A(?=5)(?=[a-z])&lt;/code&gt; doesn&amp;rsquo;t match &lt;code&gt;A5k&lt;/code&gt; and write a regex that does.
Solution: Because lookarounds &lt;a href=&#34;https://www.rexegg.com/regex-lookarounds.html#stand_their_ground&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stand their
ground&lt;/a&gt;:
they don&amp;rsquo;t alter the position in the string, so the second lookahead also
starts at A and finds a 5 rather than a letter. &lt;code&gt;A(?=5[a-z])&lt;/code&gt; does the job.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Validate that a password meets the following
&lt;a href=&#34;https://www.rexegg.com/regex-lookarounds.html#password&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;conditions&lt;/a&gt;: 1) must
have between 6 and 10 word characters, 2) must include at least one lowercase
character, 3) must include at least three uppercase characters, 4) must
include a digit. Match valid passwords. Solution: 1) &lt;code&gt;\A(?=\w{6,10}\Z)&lt;/code&gt;, 2)
&lt;code&gt;(?=[^a-z]*[a-z])&lt;/code&gt;, 3) &lt;code&gt;(?=(?:[^A-Z]*[A-Z]){3})&lt;/code&gt;, 4) &lt;code&gt;(?=[\D]*\d)&lt;/code&gt;, to
match: &lt;code&gt;.*&lt;/code&gt;. Complete solution:
&lt;code&gt;\A(?=\w{6,10}\Z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d).*&lt;/code&gt;
Discussion: Why can&amp;rsquo;t we just use &lt;code&gt;[a-z]&lt;/code&gt; to check for condition 2? This will
find a match if the string contains a lowercase letter, but, naturally, the
engine will also move to the position of that matching character, whereas we
want to stay at the first character to perform subsequent lookaheads, so we
need a match that starts at the first character.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Show two ways how to remove the redundant lookahead in the above solution.
Solution 1: &lt;code&gt;\A(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})(?=\D*\d)\w{6,10}\Z&lt;/code&gt;
Solution 2: &lt;code&gt;\A(?=\w{6,10}\Z)(?=[^a-z]*[a-z])(?=(?:[^A-Z]*[A-Z]){3})\D*\d.*\Z&lt;/code&gt;
Discussion: When using n lookaheads to validate n conditions we can always put
the regex from any of the lookaheads at the end and use it to validate a
particular pattern &lt;em&gt;and&lt;/em&gt; to match the entire string. If the condition doesn&amp;rsquo;t
already match the entire string as in solution 1, we can always add &lt;code&gt;.*\Z&lt;/code&gt;.
Why do we need the \Z? Because unless we are in dotall mode, &lt;code&gt;.&lt;/code&gt; doesn&amp;rsquo;t match
linebreaks and thus gets us to the end of the line rather than the end of the
string. To ensure that the pattern works for the entire string, we thus need
\Z.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explain why, to validate the password above, we need the contrast pattern for
parts 2-4 of the solution (i.e. why do we need &lt;code&gt;[^a-z]*[a-z]&lt;/code&gt; instead of
&lt;code&gt;[a-z]&lt;/code&gt;? Solution: because the lookahead doesn&amp;rsquo;t look into the distance but at
the character that immediately follows the current position. &lt;code&gt;[a-z]&lt;/code&gt; checks
whether what immediately follows the current position is a lowercase
character. What we want is to check whether, immediately following the current
position.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Validation: Match a single word character that is not an A. Do so using 1)
character class set operations, 2) a lookahead, 3) a lookbehind. Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;[\w--Q]&lt;/code&gt;, 2) &lt;code&gt;(?!Q)\w&lt;/code&gt;, 3) &lt;code&gt;\w(?&amp;lt;!Q)&lt;/code&gt;. The latter two are the password
validation approach from above.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tempering the scope of a token: Match any character as long as it&amp;rsquo;s not
followed by &lt;em&gt;{end}&lt;/em&gt;. Solution: &lt;code&gt;(:(?!{end}).)*&lt;/code&gt;. Discussion: each &lt;code&gt;.&lt;/code&gt; is
tempered by the negative lookahead, which specifies that the dot cannot be
the beginning of the string &lt;em&gt;{end}&lt;/em&gt;. We have thus a tempered version of &lt;code&gt;.*&lt;/code&gt;
&amp;ndash; making sure it matches anything except a particular pattern, which can be
useful if, for instance, we want to match anything up to a certain pattern
(see tempered greedy token
&lt;a href=&#34;https://www.rexegg.com/regex-quantifiers.html#tempered_greed&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;solution&lt;/a&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delimiters: Match everything between &lt;em&gt;#start#&lt;/em&gt; and &lt;em&gt;#end#&lt;/em&gt;. Solution:
&lt;code&gt;(?&amp;lt;=#end#).*?(?=#end#)&lt;/code&gt;. Discussion: we make the dot-start lazy by adding
&lt;code&gt;?&lt;/code&gt; to ensure that the engine matched the first end tag that accurs after the
start string rather than the last one.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inserting text at a
&lt;a href=&#34;https://www.rexegg.com/regex-lookarounds.html#camelinsert&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;position&lt;/a&gt;: Insert
an underscore between words in strings that are in CamelCase. Solution:
&lt;code&gt;(?&amp;lt;=[a-z])(?=[A-Z])&lt;/code&gt; finds the positions, string replacement tool does the
rest (see
&lt;a href=&#34;https://fabiangunzinger.github.io/blog/python/2021/09/11/regex-in-python.html#Insert-text-in-position&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;
for an example).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finding overlapping
&lt;a href=&#34;https://www.rexegg.com/regex-lookarounds.html#overlapping&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;matches&lt;/a&gt;: Write a
pattern that extracts &lt;em&gt;abc&lt;/em&gt;, &lt;em&gt;bc&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt; from &lt;em&gt;abc&lt;/em&gt;. Solution: &lt;code&gt;(?=(\w))&lt;/code&gt; with
GLOBAL flag (&lt;code&gt;re.findall()&lt;/code&gt; in Python). Discussion: an unanchored lookaround
with a capturing group is just what we need here: at each position, the
engine looks ahead until &lt;code&gt;\w+&lt;/code&gt; stops matching and captures the string in
between, then moves one position forward in the string and repeats.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compound
&lt;a href=&#34;https://www.rexegg.com/regex-lookarounds.html#back_to_the_future&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;lookarounds&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;match a number that is preceded and followed by exactly one underscore.
Solution: &lt;code&gt;(?&amp;lt;=(?&amp;lt;!_)_)\d+(?=_(?!_))&lt;/code&gt;. Discussion: the compound lookbehind
asserts that what precedes the position at the beginning of the number is a
position that is not preceded by an underscore but itself contains an
underscore. The compound lookahead asserts that what immediately follows the
position at the end of the number is a position with an underscore that is
not followed by another underscore.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the string &lt;code&gt;_rabbit _dog _mouse DIC🐱dog:mouse&lt;/code&gt;, where the DIC list
at the end contains the list of allowed animals, match each &lt;em&gt;_token&lt;/em&gt;
named after animals in the allowed list. Solution: &lt;code&gt;_(\w+)\b(?=.*:\1\b)&lt;/code&gt;.
Discussion: don&amp;rsquo;t forget the second word boundary, as without it, we&amp;rsquo;d also
match &lt;em&gt;_dog&lt;/em&gt; if only &lt;em&gt;doggie&lt;/em&gt; were in the allowed list. It&amp;rsquo;s not clear to me,
though, why I need the first boundary.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the above string, why does &lt;code&gt;_(?=.*:(\w+)\b)\1\b)&lt;/code&gt; only match &lt;em&gt;_mouse&lt;/em&gt;?
Solution: Two reasons: 1) because &lt;code&gt;*&lt;/code&gt; is greedy and, upon finding an
underscore in the string, shoots all the way to the end of the string and
backtracks only far enough to match the first colon, which is the one before
&lt;em&gt;mouse&lt;/em&gt;. Second: because the engine doesn&amp;rsquo;t backtrack into lookarounds. Once
the lookaround has evaluated as true of false, a failure to match further
down in the regex doesn&amp;rsquo;t cause the engine to go back into the lookaround and
backtrack further. Hence, lookarounds are
&lt;a href=&#34;https://www.rexegg.com/regex-lookarounds.html#atomic&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;atomic&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;flags-and-inline-modifiers&#34;&gt;Flags and inline modifiers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;To use flags in Python&amp;rsquo;s &lt;code&gt;re&lt;/code&gt; module, pass the keyword &lt;code&gt;flags=re.FLAGNAME&lt;/code&gt; to
the method (e.g. &lt;code&gt;re.findall(pattern, string, flags=re.MULTILINE)&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Flag (inline modifier)&lt;/th&gt;
&lt;th&gt;Legend&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[A]SCII (?a)&lt;/td&gt;
&lt;td&gt;Make tokens match ASCII rather than Unicode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GLOBAL&lt;/td&gt;
&lt;td&gt;Don&amp;rsquo;t return after first match (use &lt;code&gt;re.findall()&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[I]GNORECASE (?i)&lt;/td&gt;
&lt;td&gt;Case insensitive matching&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[M]ULTILINE (?m)&lt;/td&gt;
&lt;td&gt;Make ^ and $ match end of line (not end of string)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S, DOTALL (?s)&lt;/td&gt;
&lt;td&gt;Make . match newline (also called single-line)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X, VERBOSE (?x)&lt;/td&gt;
&lt;td&gt;Allow linebreaks for easier-to-read regexes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;subroutines-and-recursive-expressions&#34;&gt;Subroutines and recursive expressions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The backreference &lt;code&gt;\1&lt;/code&gt; repeats the &lt;em&gt;characters captured&lt;/em&gt; by the first capturing group;
subroutine &lt;code&gt;(?1)&lt;/code&gt;, the &lt;em&gt;pattern defined&lt;/em&gt; by the first capturing group. This can be very
useful to make long expressions shorter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is lots
&lt;a href=&#34;https://www.rexegg.com/regex-disambiguation.html#subroutines&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;more&lt;/a&gt; to
subroutines, but for my current use cases, the basics are enough.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Recursive patterns are related to subroutines in that a soubroutine can call
itself recursively. In addition, &lt;code&gt;(?R)&lt;/code&gt; tries to match the entire pattern
recursively (&lt;a href=&#34;https://www.regular-expressions.info/recurse.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;This&lt;/a&gt;
description of the steps the engine takes is very useful).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Match instances of &lt;em&gt;Harry meets Sally&lt;/em&gt; and &lt;em&gt;Sally meets Harry&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match strings of the form &lt;em&gt;ab&lt;/em&gt;, &lt;em&gt;aabb&lt;/em&gt;*, &lt;em&gt;aaabbb&lt;/em&gt;**.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match the same strings as above, but now as part of a larger string that
might contain other characters, including &lt;em&gt;aab&lt;/em&gt;, which we&amp;rsquo;d not want to
match.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Match stand-alone strings of the form &lt;em&gt;bbmmee&lt;/em&gt;, &lt;em&gt;bme&lt;/em&gt;, &lt;em&gt;bbbmmmeee&lt;/em&gt; that
might possibly occur as part of a larger string.
&lt;code&gt;\b(b(?&amp;gt;(?1)|m)*e)\b&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(Harry|Sally) meets (?1)&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a(?R)?b&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\b(a(?1)b)\b&lt;/code&gt;. Discussion: this requires wrapping a recursively called
subroutine in word boundaries. Using &lt;code&gt;(?R)&lt;/code&gt; instead of &lt;code&gt;(?1)&lt;/code&gt; would only
match &lt;em&gt;ab&lt;/em&gt;, since the recursion would also try to match repeated word
boundaries.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\b(b(?&amp;gt;(?1)|m)+e)\b&lt;/code&gt;. Discussion: We need to use a subroutine rather than a
recursion of the entire pattern for the same reason as in the previous
exercise. The real action happens inside the capturing group:
&lt;code&gt;(b(?&amp;gt;(?1)|m)+e)&lt;/code&gt; represents the &lt;a href=&#34;https://www.regular-expressions.info/recurse.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;generic
pattern&lt;/a&gt; pattern to match
balanced constructs (I use a &lt;code&gt;+&lt;/code&gt; instead of a &lt;code&gt;*&lt;/code&gt; quantifier on the atomic
group, which ensures there is at least one middle element). How does it
work? For the string &lt;em&gt;bbmmee&lt;/em&gt;, the first &lt;em&gt;b&lt;/em&gt; in the pattern matches, so the
engine advances and reaches the alternation inside the atomic group, from
which the subroutine matches the second &lt;em&gt;b&lt;/em&gt;. The engine again moves on to
the alternation, which now matches &lt;em&gt;m&lt;/em&gt; greedily one or more times, meaning
it eats up all the &lt;em&gt;m&lt;/em&gt;s in the centre of the pattern.  Finally, the engine
tries to match the first &lt;em&gt;e&lt;/em&gt; and succeeds, which means it has successfully
matched the entire recursive call.  The engine now goes back to the initial
pattern and tries to match the final &lt;em&gt;e&lt;/em&gt;, which also succeeds and results in
a successful overall match. We use an atomic group to avoid the engine from
unnecessary backtracking (e.g.  after matching multiple &lt;em&gt;m&lt;/em&gt;s but failing to
match an &lt;em&gt;e&lt;/em&gt;, the engine would release each &lt;em&gt;m&lt;/em&gt; and attempt to match &lt;em&gt;e&lt;/em&gt;
again, which will never succeed).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;character-class-set-opetations&#34;&gt;Character class set opetations&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;regex&lt;/code&gt; module has supports the set operations intersection, union, and
subtraction on character classes. (Inner brackets are optional but can help
with readability.)&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;Pattern&lt;/th&gt;
&lt;th&gt;String&lt;/th&gt;
&lt;th&gt;Matches&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Intersection&lt;/td&gt;
&lt;td&gt;&lt;code&gt;r&#39;[\W]&amp;amp;&amp;amp;[\S]]&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;a.k$_8&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;[&#39;.&#39;, &amp;lsquo;$&#39;]&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Union&lt;/td&gt;
&lt;td&gt;&lt;code&gt;r&#39;[ab||\d]&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;a.k$_8&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;[&amp;lsquo;a&amp;rsquo;, 8]&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Subtraction&lt;/td&gt;
&lt;td&gt;&lt;code&gt;r&#39;[\w--k]&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;a.k$_8&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;_&amp;rsquo;, 8]&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;gotchas&#34;&gt;Gotchas&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Based on &lt;a href=&#34;https://www.rexegg.com/regex-gotchas.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; page.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Why doesn&amp;rsquo;t &lt;code&gt;[a-z]+&lt;/code&gt; match &lt;em&gt;Cat&lt;/em&gt;? How can you fix it?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Why doesn&amp;rsquo;t &lt;code&gt;My .* cat&lt;/code&gt; match the below string? How can you fix it?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;My dog
and my cat&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How can we avoid the regex &lt;code&gt;cat&lt;/code&gt; from matching in the string &lt;em&gt;certificate&lt;/em&gt;
but find it in patterns like &lt;em&gt;_cat12&lt;/em&gt;?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The regex &lt;code&gt;[128]|18&lt;/code&gt; is supposed to match &lt;em&gt;1&lt;/em&gt;, &lt;em&gt;2&lt;/em&gt;, &lt;em&gt;8&lt;/em&gt;, and &lt;em&gt;18&lt;/em&gt;. In the
string &lt;em&gt;18 18&lt;/em&gt;, (a) what does it match without any flags? (b) what does it
match with the &lt;em&gt;global&lt;/em&gt; flag on? (c) when would it match &lt;em&gt;18&lt;/em&gt; and why? (d)
how could it be improved to achieve its aim?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We use the pattern &lt;code&gt;x*&lt;/code&gt; with replacement string &lt;em&gt;y&lt;/em&gt;. Running it on &lt;em&gt;x&lt;/em&gt;, we get
&lt;em&gt;yy&lt;/em&gt;, running it on &lt;em&gt;a&lt;/em&gt; we get &lt;em&gt;yay&lt;/em&gt;. What&amp;rsquo;s going on?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Because regex is case-sensitive by default and thus, as writte, only matches
lowercase characters. Could either us an inline modifier &lt;code&gt;(?i)[a-z]+&lt;/code&gt; or
explicitly search for uppercase and lowercase characters &lt;code&gt;[A-Za-z]+&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Because &lt;code&gt;.&lt;/code&gt; does not match line breaks by default. The easiest way to fix
this is to use &lt;em&gt;DOTALL mode&lt;/em&gt; (also called &lt;em&gt;single-line mode&lt;/em&gt;) &lt;code&gt;(?s) My .* cat&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If we only ever wanted &lt;em&gt;cat&lt;/em&gt; on its own, simple word boundaries &lt;code&gt;\bcat\b&lt;/code&gt;
would do. To match it when surrounded by non-letter word characters, we need
&lt;a href=&#34;https://www.rexegg.com/regex-boundaries.html#real-word-boundary&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;real-word
boundaries&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(a) &lt;em&gt;1&lt;/em&gt;, (b) &lt;em&gt;[1, 8, 1, 8]&lt;/em&gt;. This surprised me for a moment: remember that
the engine scans alternatives in the regex left to right, eagerly returns
the first match, and then moves on to the next character in the string. (c)
Never, since it will always match the &lt;em&gt;1&lt;/em&gt; and move on without attempting to
match the right-hand side of the alternation in the pattern. (d) Depending
on the context, we could just reverse the alternation to &lt;code&gt;18|[128]&lt;/code&gt;, or,
more securely, use anchors or boundaries &lt;code&gt;\b(?:[128]|18)\b&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Zero matches! In the first case, &lt;code&gt;x*&lt;/code&gt; first matches &lt;em&gt;x&lt;/em&gt; at position 0 of the
string and replaces it with &lt;em&gt;y&lt;/em&gt;, and then matches the empty space at
position 1 after the &lt;em&gt;x&lt;/em&gt; and replaces it as well. In the second case, the
regex matches the empty string at position zero and replaces it, moves past
the &lt;em&gt;a&lt;/em&gt; to position 1, and again matches and replaces the empty string,
giving us &lt;em&gt;yay&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;the-elements-of-regex-style&#34;&gt;The elements of regex style&lt;/h2&gt;
&lt;p&gt;Inspired and heavily based on
&lt;a href=&#34;https://www.rexegg.com/regex-style.html#contrast&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; fantastic section from
the RexEgg page.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To write good regex, say shat you mean. Say it clearly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;A string goes from \A to \Z (in &lt;code&gt;re&lt;/code&gt;; to \z, in &lt;code&gt;regex&lt;/code&gt;).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Summary mnemonic: &lt;strong&gt;Greedy atoms anchor again.&lt;/strong&gt;: greedy vs lazy, the cost of
greedy and workarounds (say what you want, contrast); should parts be made
atomic?; should I use anchors or boundaries?; should I use repeating
subpattern syntax?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To match or to capture? The full match is just another capture, in Python and
many other engines referred to as group 0 and, by convention called &amp;ldquo;the
match&amp;rdquo;. So there is no difference between the two approaches. Best practice
advise: use whatever gets the job done, while aiming to reduce overhead by
reducing the number of capturing groups (use non-capturing groups if useful).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To split or to match all? They are a different way of looking at the same
approach, so use whichever is easier to get the job done.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Whenever possible, anchor. It ensures that the engine finds the match in the
right place, and often saves unnecessary backtracking.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Say what you want and don&amp;rsquo;t want, and avoid &amp;ldquo;dot-star soup&amp;rdquo;. It saves
unnecessary backgtracking and is clearer to read.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create contrast with consequtive tokens that are mutually exclusive (&lt;code&gt;\D&lt;/code&gt; and
&lt;code&gt;\d&lt;/code&gt;, or &lt;code&gt;[^a-z]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt;). It can simplify patterns and save unnecessary
backtracking. Example: to find strings with exactly three digits that are
located at the end, I might start with ^.+\d{3}$. This doesn&amp;rsquo;t work because .
also matches digits, so I&amp;rsquo;d match abc12345. I could use negative lookbehind
like so: &lt;code&gt;^.+(?\&amp;lt;!\d)&lt;/code&gt;, but this would still match ab3c123. The real solution
is to use mutually exclusive tokens to start with: ^\D+\d{3}$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beware of lazyness. Avoid lazy quantifiers in favour and use contrast to say
what you want to save unnecessary backtracking. Example: &lt;code&gt;{.*?}&lt;/code&gt; matches
everything inside curly brackets, but backtracking is
&lt;a href=&#34;https://www.rexegg.com/regex-quantifiers.html#lazy_expensive&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;costly&lt;/a&gt; as
they backtrack at every step. &lt;code&gt;{[^}]*}&lt;/code&gt; is more direct and faster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use greediness and laziness deliberately. A greedy quantifier may shoot all
the way to the end of the string, a lazy one tuck along backtracking at every
step. Either can be useful when employed for a suitable purpose.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use atomic quantifiers. They can save a lot of backtracking.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Design to fail: Compose regexes to minimise the number of unnecessary
unsuccessful attempts. Example: with GLOBAL and MULTILINE modes on,
&lt;code&gt;(?=.*flea).*&lt;/code&gt; matches lines that contain &amp;ldquo;flea&amp;rdquo;. But for lines that don&amp;rsquo;t
contain flea, it unnecessarily tries the lookahead at every single character.
Anchoring the lookahead at the start of the line, &lt;code&gt;^(?=.*flea).*&lt;/code&gt;, remedies
that by only looking ahead from the first position of each line.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trust the dot-star to get you to the end of the line. It allows you to
simplify patterns. Example: in a string such as &lt;em&gt;@abc @bcd&lt;/em&gt; you want to match
the last token if and only if the string contains more than one token.
&lt;code&gt;@[a-z]+$&lt;/code&gt; won&amp;rsquo;t do because it also matches the last token if there is only
one. &lt;code&gt;@[a-z].*\K@[a-z]+&lt;/code&gt; does the trick, as the dot-start will shoot all the
way to the end and then backtrack as as needed to match the rest of the
pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To validate n conditions and capture strings that meet them, use n-1
&lt;a href=&#34;https://www.rexegg.com/regex-lookarounds.html#n-1conds&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;lookaheads&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;miscellaneous&#34;&gt;Miscellaneous&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;From tokens of the form &lt;em&gt;abc_12&lt;/em&gt;, return only the digits. Solution: a simple
way is to use the keep out token, which discards anything matched before it:
&lt;code&gt;\w+_\K\d+&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check whether string length is a multiple of 2, then a multiple of n.
Solution: &lt;code&gt;^(?:..)+$&lt;/code&gt; checks for multiples of two, &lt;code&gt;^(?:.{n})+$&lt;/code&gt; for
multiples of &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;frequently-used-patterns&#34;&gt;Frequently used patterns&lt;/h2&gt;
&lt;p&gt;Work in progress:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Match all strings inside quotation marks in the below block.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are &amp;lsquo;string one&amp;rsquo; and &amp;lsquo;string
two&amp;rsquo; and &amp;lsquo;that&amp;rsquo;s string three&amp;rsquo;.&lt;/p&gt;
&lt;p&gt;Thus far (with global flag/&lt;code&gt;findall()&lt;/code&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;.*&amp;rsquo; Doesn&amp;rsquo;t work because * is greedy and matches &amp;lsquo;string one&amp;rsquo; and &#39; and
similar match on second line.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;.*?&amp;rsquo; Doesn&amp;rsquo;t match string two since . doesn&amp;rsquo;t match line-breaks and get&amp;rsquo;s
mixed up on second line.&lt;/li&gt;
&lt;li&gt;[^&#39;\v]+ Behaves as the above&lt;/li&gt;
&lt;li&gt;[^&#39;]+ Now matches second string but including the linebreak, which we don&amp;rsquo;t
want as part of the match, and still gets tripped up by that&amp;rsquo;s.&lt;/li&gt;
&lt;li&gt;Wanted: match string two but then exclude \v from match, ignore &#39; that are
part of a word.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Regular expressions
cookbook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.rexegg.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RexEgg, awesome online regex resource&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.regular-expressions.info&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Regular-Expressions.info, another excellent online
resource&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://regex101.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Regular Expressions 101, very good regex tester&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pandas categories</title>
      <link>https://fabiangunzinger.github.io/post/pandas-categories/</link>
      <pubDate>Thu, 11 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/pandas-categories/</guid>
      <description> &lt;iframe
       src=&#34;./pandas-categories.html&#34;
       width=&#34;90%&#34;
       height=&#34;4200px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Python string formatting</title>
      <link>https://fabiangunzinger.github.io/post/python-string-formatting/</link>
      <pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/python-string-formatting/</guid>
      <description> &lt;iframe
       src=&#34;./python-string-formatting.html&#34;
       width=&#34;90%&#34;
       height=&#34;7000&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Python regex</title>
      <link>https://fabiangunzinger.github.io/post/python-regex/</link>
      <pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/python-regex/</guid>
      <description> &lt;iframe
       src=&#34;./python-regex.html&#34;
       width=&#34;90%&#34;
       height=&#34;15400&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Vim</title>
      <link>https://fabiangunzinger.github.io/post/vim/</link>
      <pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/vim/</guid>
      <description>&lt;h2 id=&#34;preliminaries&#34;&gt;Preliminaries&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I use &lt;a href=&#34;https://neovim.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;neovim&lt;/a&gt;. My configuration is
&lt;a href=&#34;https://github.com/fabiangunzinger/dotfiles/blob/main/init.vim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.
There, I map &lt;code&gt;&amp;lt;esc&amp;gt;&lt;/code&gt; to &lt;code&gt;jk&lt;/code&gt;, a mapping I also use throughout this
file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I&amp;rsquo;ve remaped Caps Look to &lt;code&gt;&amp;lt;ctrl&amp;gt;&lt;/code&gt; on my mac.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reminders&#34;&gt;Reminders&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use one keystroke to move and one to execute (e.g. the dot-formula).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exit and re-enter insert mode strategically to chunk your undos (all changes
in a single insert session count as one change).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you hit cursor keys more than 2 or 3 times, press backspace more than a
couple times, perform the same change on several lines, there is a better
way.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I want to open a file and get an &lt;em&gt;E325: ATTENTION Found a swap file&lt;/em&gt; warning.
What happened? For me, it&amp;rsquo;s most likely that I accidentally closed a terminal
window while still editing the file. What to do? First, check that I&amp;rsquo;m not
already editing the file elsewhere. Second, recover the file, save it under a
new name (&lt;code&gt;:w filename2&lt;/code&gt;), force quit the session, compare the original and
the new file (&lt;code&gt;diff filename filename2&lt;/code&gt;), use the file with the content I
need and delete the other one and the swap file. (Based on
&lt;a href=&#34;https://superuser.com/a/498658&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; great SE answer.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Don&amp;rsquo;t solve a problem unless you come across it frequently (and if you do,
check whether one of Tim Pope&amp;rsquo;s plugins solves it).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Useful stuff I tend to forget:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-f&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;C-b&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Scroll down/up screen-wise (&amp;ldquo;forwards-backwards&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;c-x c-e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;In command line: edit current line in vim, run after quit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Like &lt;code&gt;:wq&lt;/code&gt; but only write if file was changed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;set: {option}?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Show present setting for {option}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;set: {option}&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Set option back to default value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Command separator (equivalent to &lt;code&gt;;&lt;/code&gt; in shell)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-k&amp;gt;-N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Enter en dash in insert mode using digraphs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-o-o&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;After opening vim, opens last file with cursor at last&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;edit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;help&#34;&gt;Help&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Show table of contents for current help file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:helpc[lose]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Close help windows if any are open&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:vert h {keyword}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open help in a vertical split&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;modes&#34;&gt;Modes&lt;/h2&gt;
&lt;h3 id=&#34;normal-mode&#34;&gt;Normal mode&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Operators work as follows: operator + motion = action. E.g. &lt;code&gt;dl&lt;/code&gt; deletes
character to the right, &lt;code&gt;diw&lt;/code&gt; the word under the cursor (without the
surrounding whitespace), &lt;code&gt;dap&lt;/code&gt; the current paragraph (including the
surrounding whitespace). Similarly, &lt;code&gt;gUap&lt;/code&gt; converts the current paragraph to
uppercase.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Common operators:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Trigger&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Change&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Delete into register&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Yank into register&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Paste after cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;P&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Paste before cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Swap case of character under cursor and move right&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gu&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Make lowercase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gU&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Make uppercase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g~&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Swap case&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shift right&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shift left&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Autoindent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Filter {motion} lines through an external program&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Moving back and forth:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Forwards&lt;/th&gt;
&lt;th&gt;Backwards&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Seach for pattern&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Search for word under cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to next search match&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to end of line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;F{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Position cursor on character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;t{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;T{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Position cursor before character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;,&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Repeat the last r, F, t, or T&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move to the start of the next word&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move to the start of the next WORD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move down one (blank-line-separated) paragraph&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Jump to the first line of the document&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Jump to the last line of the document&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Act, repeat, reverse:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Intent&lt;/th&gt;
&lt;th&gt;Act&lt;/th&gt;
&lt;th&gt;Repeat&lt;/th&gt;
&lt;th&gt;Reverse&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Make a change&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{edit}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scan line for next character&lt;/td&gt;
&lt;td&gt;&lt;code&gt;f{char}/t{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;,&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scan line for previous character&lt;/td&gt;
&lt;td&gt;&lt;code&gt;F{char}/T{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;,&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scan document for next match&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/pattern&amp;lt;CR&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scan document for previous match&lt;/td&gt;
&lt;td&gt;&lt;code&gt;?pattern&amp;lt;CR&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;N&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Perform substitution&lt;/td&gt;
&lt;td&gt;&lt;code&gt;:s/old/new&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Execute a sequence of changes&lt;/td&gt;
&lt;td&gt;&lt;code&gt;qx{change}q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Compound commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Compound command&lt;/th&gt;
&lt;th&gt;Equivalent in longhand&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;C&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;c$&lt;/code&gt; (delete from cursor until end of line and start insert)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;d$&lt;/code&gt; (delete from cursor until end of line)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;y$&lt;/code&gt; (similar to above, but has to be mapped, see &lt;code&gt;h: Y&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cl&lt;/code&gt; (delete single character and start insert)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^c&lt;/code&gt; (delete entire line and start inster, synonym for &lt;code&gt;cc&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dl&lt;/code&gt; (delete one character to the right)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dh&lt;/code&gt; (delete one character to the left)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;I&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^i&lt;/code&gt; (jump to beginning of line and start insert)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$a&lt;/code&gt; (jumpt to end of line and start insert)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;A&amp;lt;cr&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ko&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Miscellaneous:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-a&amp;gt;&lt;/code&gt;/ &lt;code&gt;&amp;lt;C-x&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Add / subtract from the next number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-o&amp;gt;&lt;/code&gt;/ &lt;code&gt;&amp;lt;C-i&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move backwards to last / forward to previous location&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;/&lt;code&gt;&amp;lt;C-r&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Undo / redo change&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ga&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Reveal numeric representation of character under cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open url under cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-z&amp;gt;&lt;/code&gt;/&lt;code&gt;fg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Put vim in background / return to vim&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;insert-mode&#34;&gt;Insert mode&lt;/h3&gt;
&lt;p&gt;Entering insert mode:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Trigger&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert before cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert after cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;I&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert at beginning of current line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;A&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert at end of current line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert in a new line below the current one&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert in a new line above the current one&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert at the end of last insert&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Useful commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Keystroke&lt;/th&gt;
&lt;th&gt;action&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-h&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;delete back one character (backspace)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-w&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;delete back one word&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-u&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;delete back one line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-o&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Enter insert normal mode to execute a single normal cmd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;{register}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Paste content from address (use 0 for last yanked text)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Perform calculation in place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;r&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Enter replace mode for single replacement or until exit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-v&amp;gt;{123}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert character by decimal code&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-v&amp;gt;u{1234}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert character by hexadecimal code&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-v&amp;gt;{char1}{char2}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert character by digraph&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;visual-mode&#34;&gt;Visual mode&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Once in visual mode, you can use any normal mode movement command to specify
the area to be selected. Reminder to myself: use search more often for this.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Enter character-wise visual mode / back to normal mode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Enter line-wise visual mode / back to normal mode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-v&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Enter block-wise visual mode / back to normal mode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Reselect last visual selection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle the free end of a selection&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;command-line-mode&#34;&gt;Command-line mode&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ex-commands allow you to make changes (in multiple places) anywhere in
the file without moving the cursor &amp;ndash; &amp;ldquo;they strike far and wide&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The general syntax is &lt;code&gt;:[range]{command}&lt;/code&gt;, where &lt;code&gt;[range]&lt;/code&gt; is
either a single address or a range of addresses of the form &lt;code&gt;{start},{stop}&lt;/code&gt;.
There are three types of addresses: line numbers, visual selections, and
patterns.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To execute a command on all selected lines, use visual mode to make the
selection and press &lt;code&gt;:&lt;/code&gt;. This will start the command prompt with &lt;code&gt;&#39;&amp;lt;, &#39;&amp;gt;:&lt;/code&gt;,
to which you can then add the command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can also specify offsets. For example, &lt;code&gt;:/&amp;lt;tag&amp;gt;/+1&amp;lt;\/tag&amp;gt;/-1{cmd}&lt;/code&gt; would
operate on the lines inside the html tag but not the lines containing the tag
marks.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Command mode commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Opens command line / search /reverse search mode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;&amp;lt;C-w&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert word under cursor in command prompt&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;left&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;right&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move one character left or right&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;S-left&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move one word left (similar for right)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-b&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;C-e&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move to the beginning/end of the command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Delete last word&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-u&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Delete from cursor to beginning of line&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Types of addresses:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:4{cmd}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;execute command on line 4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:4,8{cmd}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;execute command on lines 4 to 8 (inclusive)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:/#/{cmd}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;execute command on next line with an &lt;code&gt;#&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:/&amp;lt;tag&amp;gt;/&amp;lt;\/tag&amp;gt;/{cmd}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Execute command on next occurring html tag&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&#39;&amp;lt;,&#39;&amp;gt;{cmd}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Execute command on selected lines&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Useful address/range characters:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Symobol&lt;/th&gt;
&lt;th&gt;Address&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;First line of the file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Last line of the file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Virtual line above first line (e.g. to paste to top of file)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Line of cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Line containing mark m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Start of visual selection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&#39;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;End of visual selection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The entire file (short for &lt;code&gt;:1,$&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Common Ex-commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p[rint]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Print&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d[elete]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;j[oin]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Join lines&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s[ubstitute]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Substitute (e.g. &lt;code&gt;s/old/new&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;n[ormal]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Execute normal mode command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;m[ove]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move to &lt;code&gt;{address}&lt;/code&gt;, (e.g. &lt;code&gt;:1,5m$&lt;/code&gt; moves lines to end of file)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;co[py]&lt;/code&gt; (or &lt;code&gt;t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Copy to &lt;code&gt;{address}&lt;/code&gt;, (e.g. &lt;code&gt;:6t.&lt;/code&gt; copies line 6 to current line)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Wrap all elements in the first column of a table in quotes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replace the word under the cursor throughout the file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open help for word under the cursor.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;With cursor on word in first row: &lt;code&gt;:{start},{stop}normal ysaW&#39;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;cw{change}jk&lt;/code&gt;, &lt;code&gt;:%s//&amp;lt;C-r&amp;gt;&amp;lt;C-w&amp;gt;/&amp;lt;options&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:h &amp;lt;C-r&amp;gt;&amp;lt;C-w&amp;gt;&amp;lt;CR&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;quickfix-list&#34;&gt;Quickfix List&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The quickfix list is a special mode to speed up the edit-compile-edit cycle.
But it can be used more generally to find a list of positions in files (e.g.
list could hold search matches from running &lt;code&gt;:vimgrep&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Location list is a local version of the quickfix list that is bound to the
currently active window. There can be as many local lists as there are
windows, while there is only a single globally available quickfix list.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:make [target]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Compile target (and jump to first error if there are some)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:make! [target]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Compile target without jumping to first error&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:copen&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open quickfix window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:cclose&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Close quickfix window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]q&lt;/code&gt; / &lt;code&gt;[q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to next/previous match (uses vim-unimpaired plugin)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;files&#34;&gt;Files&lt;/h2&gt;
&lt;p&gt;Setting the working directory:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:pwd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Show current directory window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Set directory for all windows&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:cd -&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Revert back to previous directory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:lcd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Set directory for current window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:tcd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Set directory for current tab&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;buffers&#34;&gt;Buffers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A buffer is an in-memory representation of a file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A hidden buffer is one that contains changes you haven&amp;rsquo;t written to disk
yet but switched away from. For a session with hidden buffers, quitting will
raise error messages, and vim will automatically display the first hidden
buffer. You now have the following options: &lt;code&gt;:w[rite]&lt;/code&gt; to write the buffer&amp;rsquo;s
content to disk, &lt;code&gt;:e[dit]!&lt;/code&gt; to reread the file from disk and thus revert all
changes made, &lt;code&gt;:qa[ll]!&lt;/code&gt; to discard all changes, and &lt;code&gt;:wa[ll]&lt;/code&gt; to write all
modified buffers to disk.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:bufdo&lt;/code&gt; executes an Ex command in all open buffers, &lt;code&gt;:argo&lt;/code&gt; in all grouped
ones (e.g. &lt;code&gt;:argdo %s/hello/world/g&lt;/code&gt; substitutes &lt;code&gt;world&lt;/code&gt; for &lt;code&gt;hello&lt;/code&gt; in all
buffers in &lt;code&gt;:args&lt;/code&gt;, &lt;code&gt;:argdo edit!&lt;/code&gt; reverts all changes, and &lt;code&gt;:argdo update&lt;/code&gt;
writes changed buffers to disk.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:[range]bd&lt;/code&gt; deletes buffers in range, with &lt;code&gt;[range]&lt;/code&gt; working as for other
Ex-commands (see above).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:x[it]&lt;/code&gt; / &lt;code&gt;exi[t]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Like &lt;code&gt;:wq&lt;/code&gt; but only write if file was changed&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:xa&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Write all changed buffers and exit (like &lt;code&gt;:wqa&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/tpope/vim-eunuch&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;vim-eunuch&lt;/a&gt; commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Move[!] {file}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Like &lt;code&gt;:saveas&lt;/code&gt;, but deletes old file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Rename[!] {file}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rename current buffer and file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Chmod {mode}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Change permissions of current file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Mkdir {dir}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Create dir with &lt;code&gt;mkdir()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Mkdir! {dir}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Create dir with &lt;code&gt;mkdir()&lt;/code&gt; with &amp;ldquo;p&amp;rdquo; argument (mkdir -p)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Toggle buffer settings from vim-unimpaired:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;yoh&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle search highlighting&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;yob&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle light background&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;yoc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle cursor line highlighting&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;yon&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle line numbers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;yor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle relative line numbers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;yos&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle the spell checker&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;windows&#34;&gt;Windows&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A window is a viewport onto a buffer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We can open different windows that all provide a (different) view onto the
same buffer, or load multiple buffers into one window.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Go to next window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Split window horizontally&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Split window vertically&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:sp[lit] {file}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Horizontally split window and load {file} into new buffer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:vsp[lit] {file}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Vertically split window and load {file} into new buffer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:new&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Split horizontally with new file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:vne[w]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Split vertically with new file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;on[ly]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Close all but current window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Equalize width and height of all windows&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rorate windows&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Exchange position of current window with its neighbour&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;q[uit]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Close current window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:sb[uffer]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open buffer number N in horizontal split&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:vert sb N&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open buffer number N in vertical split (&lt;code&gt;&amp;lt;leader&amp;gt;vb&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tabs&#34;&gt;Tabs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A tab is a container of windows.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:tabe[dit]{file}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open new tab with {file} if specified or empty otherwise&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:[count]tabnew&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open a new tab in an empty window.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move current window into new tab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:tabc[lose]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Close current tab with all its windows&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:tabo[nly]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Close all tabs but the current one&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{N}&lt;/code&gt;gt&lt;/td&gt;
&lt;td&gt;Go to tab {N} if specified, or to next otherwise&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Go to previous tab&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Handy [count] options for &lt;code&gt;tabnew&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Count&lt;/th&gt;
&lt;th&gt;Opens new tab &amp;hellip;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[.]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;hellip; after current one&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;hellip; before current one&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;hellip; before first one&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;hellip; after last one&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;opening-files&#34;&gt;Opening files&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I use &lt;code&gt;command-t&lt;/code&gt; to fuzzy-find files, which is what I use most of the time
when working inside a project. I used &lt;code&gt;ctrl-p&lt;/code&gt; before and prefer some of the
mappings, hence my repammings.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To navigate file trees, I use &lt;code&gt;netrw&lt;/code&gt; and &lt;code&gt;vinegar&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deleting folders: &lt;code&gt;netrw&lt;/code&gt; uses &lt;code&gt;delete()&lt;/code&gt; with the &lt;code&gt;d&lt;/code&gt; flat to delete
directories. As explained in &lt;code&gt;:h delete()&lt;/code&gt;, this only removes empty
directories. I leave this default for now.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To easily open a new file from the same directory as the current buffer in a
new window/split/vertical split/tab I use the mappings &lt;code&gt;&amp;lt;leader&amp;gt;ew/es/ev/et&lt;/code&gt;,
following &lt;a href=&#34;http://vimcasts.org/episodes/the-edit-command/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; Vimcast.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;command-t commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-o&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open or close command-t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-i&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open command-t for open buffers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-f&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Flush path cash and rescan directory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-v&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open file in vertical split&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;netrw&lt;/code&gt; commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e[dit].&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open file explorer for current working directory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;E[xplore]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open file explorer for the directory of active buffer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open new file in current directory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Create new directory in current one&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rename file or directory under cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Delete file or directory under cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gh&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle hiding dot-files&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:Ve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open explorer in vertical split&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:Rex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Exit/return to explorer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;c-l&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Refresh listing&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;navigation&#34;&gt;Navigation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Motions move within a file, jumps between files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each motion can be prepended by a count (&lt;code&gt;5l&lt;/code&gt; moves five characters to the
right).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;within-files&#34;&gt;Within files&lt;/h3&gt;
&lt;p&gt;General:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-g&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Shows current filepath and line number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zz&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Redraw current line in middle of window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zt&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Redraw current line at top of window&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Left-right and up-down:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You can use search after an operator to great effect. For instance: typing
&lt;code&gt;d/to &amp;lt;CR&amp;gt;&lt;/code&gt; when the cursor is at the beginning of &amp;ldquo;after&amp;rdquo; in the previous
sentence turns it into &amp;ldquo;You can use search to greate effect&amp;rdquo;. This works
because &lt;code&gt;d&lt;/code&gt; is an exclusive operator (&lt;code&gt;h: exclusive&lt;/code&gt;) and doesn&amp;rsquo;t apply the
operation on the endpoint of the selection.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I use &lt;code&gt;vim-smoothie&lt;/code&gt; for smoother screening behaviour of half-screen and
screen-wise scrolling.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;h&lt;/code&gt;/&lt;code&gt;l&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move left/right&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;j&lt;/code&gt;/&lt;code&gt;k&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Down/up one line (think of &lt;code&gt;j&lt;/code&gt; as a down arrow)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gj&lt;/code&gt;/&lt;code&gt;gk&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Down/up by display rather than real lines&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;/&lt;code&gt;^&lt;/code&gt;/&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;To first non-blank/first/last character of line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Goto line &lt;code&gt;[count]&lt;/code&gt;, default is last line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Goto line &lt;code&gt;[count]&lt;/code&gt;, default is first line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;f{char}&lt;/code&gt;/&lt;code&gt;F{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;To next occurrence of {char} to the right/left&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;t{char}&lt;/code&gt;/&lt;code&gt;T{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Till (before) next occurrence of {char} to the right/left&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;H&lt;/code&gt;/&lt;code&gt;M&lt;/code&gt;/&lt;code&gt;L&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to the top/middle/bottom of the screen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-e&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;C-y&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Scroll down/up linewise&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-d&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;C-u&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Scroll down/up half-screen-wise (&amp;ldquo;down-up&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-f&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;C-b&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Scroll down/up screen-wise (&amp;ldquo;forwards-backwards&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Words:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;/&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Forward to start/end of current or next word&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;b&lt;/code&gt;/&lt;code&gt;ge&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Backward to start/end of current or previous word&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;W&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move WORD rather than word wise&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Text objects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Text objects come in two types: those within a pair of delimiters (e.g. text
inside parentheses) and chucks of text (Vim calls them &amp;ldquo;block&amp;rdquo; and
&amp;ldquo;non-block&amp;rdquo; objects).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;They can be moved over or selected.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Text object selection start with &lt;code&gt;i&lt;/code&gt; (&amp;ldquo;inner sentence&amp;rdquo;) or &lt;code&gt;a&lt;/code&gt; (&amp;ldquo;a
sentence&amp;rdquo;).  For example: &lt;code&gt;vi)&lt;/code&gt; highlights text inside parentheses but not
the parentheses themselves, while &lt;code&gt;va)&lt;/code&gt; highlights the parentheses as well.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;)&lt;/code&gt;/&lt;code&gt;(&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move [count] sentences forward/backward&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;}&lt;/code&gt;/&lt;code&gt;{&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Move [count] paragraphs forward/backward&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Select inside or around&amp;hellip;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;/&lt;code&gt;W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;word/WORD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;sentence&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;paragraph&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a &lt;code&gt;[]&lt;/code&gt; block&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;)&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a &lt;code&gt;()&lt;/code&gt; block&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;}&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a &lt;code&gt;{}&lt;/code&gt; block&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; block&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a tag block&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Marks:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;m{a-zA-Z}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Set lowercase (local) or uppercase (global) mark&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`{mark}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to mark&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double-backquote&lt;/td&gt;
&lt;td&gt;Go to position before last jump&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Go to position of last change&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Go to matching bracket&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;between-files&#34;&gt;Between files&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A jump is a long-range motion (which, roughly, means moving faster than
WORD-wise).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Traversing the jumps and changes lists&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:jumps&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Show the jump list&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-o&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;C-i&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Traverse jump history backwards/forwards&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:changes&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Show the change list&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g;&lt;/code&gt;/&lt;code&gt;g,&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Traverse change list backwards/forwards&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to file under cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-]&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to definition of keyword under cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;back-and-forth&#34;&gt;Back and forth&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Vim-unimpaired provides a set of normal mode commands to move between &lt;strong&gt;next&lt;/strong&gt;
(&lt;code&gt;]&lt;/code&gt;) and &lt;strong&gt;previous&lt;/strong&gt; (&lt;code&gt;[&lt;/code&gt;), toggle &lt;strong&gt;options&lt;/strong&gt;, and special &lt;strong&gt;pasting&lt;/strong&gt;.
Some commands I use often are listed below. The mnemonic is that &lt;code&gt;]&lt;/code&gt; is next
in general and &amp;ldquo;next line&amp;rdquo; here, and lowercase navigates one by one while
lowercase jumpts to first or last (e.g.  &lt;code&gt;[b&lt;/code&gt; moves to previous buffer, &lt;code&gt;[B&lt;/code&gt;
jumps to first one).&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]&amp;lt;space&amp;gt;&lt;/code&gt;/&lt;code&gt;[&amp;lt;space&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Add [count] blank lines below/above the cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]e&lt;/code&gt;/&lt;code&gt;[e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Exchanges the current line with the one below/above&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;registers&#34;&gt;Registers&lt;/h2&gt;
&lt;h3 id=&#34;copy-and-paste&#34;&gt;Copy and paste&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A register is a container that holds text. By default, Vim deletes, yanks and
puts to and from the &lt;code&gt;unnamed&lt;/code&gt; register &lt;code&gt;&amp;quot;&lt;/code&gt;. We can set the register with
which a command interacts by prepending the command with &lt;code&gt;&amp;quot;{register}{cmd}&lt;/code&gt;
(e.g. to explicitly state that we want to delete the current line to the
unnamed register, we&amp;rsquo;d use &lt;code&gt;&amp;quot;&amp;quot;dd&lt;/code&gt;; to put the just copied text, &lt;code&gt;&amp;quot;&amp;quot;p&lt;/code&gt;. But
these are equivalent to &lt;code&gt;dd&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;, so we&amp;rsquo;d probably not do that.) However,
the default register will always contains the content from the last command,
even if an additional register was specified.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transposing characters and lines: to correct &amp;ldquo;Thi sis&amp;rdquo;, starting from the last
letter, use &lt;code&gt;F&amp;lt;space&amp;gt;xp&lt;/code&gt;; to swap the current with the subsequent line, use
&lt;code&gt;ddp&lt;/code&gt;. As an alternative to &lt;code&gt;ddp&lt;/code&gt;, which is useful to move lines up and down
more flexibly, use &lt;code&gt;]e&lt;/code&gt; from &lt;code&gt;vim-unimpaired&lt;/code&gt; (see below).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Expression register: when we fetch the content of the expression register, Vim
drops into command-line mode with a &lt;code&gt;=&lt;/code&gt; prompt. When we enter Vim script and
press &lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;, Vim will coerce the result into a string if possible and use it.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;{reg}{cmd}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Make {cmd} interact with register {reg}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The unnamed register (redundant, as it&amp;rsquo;s the default)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The yank register&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;_&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The black hole register (nothing returns from it)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;{a-z}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Named registers (replace with {a-z}, append with {A-Z})&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;The system clipboard&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Name of current file (e.g. &lt;code&gt;&amp;quot;%p&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Name of alternate file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Last inserted text&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Last Ex command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Last search pattern&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:reg[ister] [reg]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;List content of registers &lt;em&gt;reg&lt;/em&gt;, all by default&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;{reg}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Paste content of {reg} in insert mode&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Useful patterns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Replace firstword with secondword. Solution 1: cursor at beginning of
secondword; &lt;code&gt;ye&lt;/code&gt;; &lt;code&gt;bb&lt;/code&gt;; &lt;code&gt;ve&lt;/code&gt;; &lt;code&gt;p&lt;/code&gt;. Solution 2: cursor at beginning of
secondword; &lt;code&gt;ye&lt;/code&gt;; &lt;code&gt;bb&lt;/code&gt;; &lt;code&gt;cw&lt;/code&gt;; &lt;code&gt;&amp;lt;C-r&amp;gt;0&lt;/code&gt;. Has advantage that &lt;code&gt;.&lt;/code&gt; now replaces
current word with &lt;code&gt;firstword&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Swap firstword and secondword. Solution: cursor at beginning of firstword;
&lt;code&gt;de&lt;/code&gt;; &lt;code&gt;mm&lt;/code&gt;; &lt;code&gt;ww&lt;/code&gt;; &lt;code&gt;ve&lt;/code&gt;; &lt;code&gt;p&lt;/code&gt;; &lt;code&gt;`m&lt;/code&gt;; &lt;code&gt;P&lt;/code&gt;. Explanation: this exploits a quirk
in the behaviour or &lt;code&gt;p&lt;/code&gt; in visual mode. When we paste in visual mode, we put
the content of the default register in place of the highlighted text, and the
highlighted text into the default register.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Complete the statement 27 * 45 = x. Solution: cursor at x and in insert
mode; &lt;code&gt;&amp;lt;C-r&amp;gt;=27*45&amp;lt;CR&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;macros&#34;&gt;Macros&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Macros can be executed &lt;em&gt;in sequence&lt;/em&gt; (e.g. &lt;code&gt;22@a&lt;/code&gt;) or &lt;em&gt;in parallel&lt;/em&gt;
(&lt;code&gt;[range]:normal @a&lt;/code&gt;). The former can be useful as it aborts on failure,
which could be what we want (e.g. replace all search results and stop once
none are left). But if it&amp;rsquo;s not, then the latter approach is more useful
(e.g. if you want to perform a change on all list items but not on other
lines).&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;q{a-z}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Start recording macro to register&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;End recording&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[count]@{a-z}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Invoke macro in register [count] times&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@@&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Replay last invoked macro&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;q{A-Z}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Append to macro (e.g. if I forgot something)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In the below block of code, prepend *var * and append &lt;em&gt;;&lt;/em&gt; to each line.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;foo = 1  
bar = 2  
baz = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Edit macro &lt;code&gt;q&lt;/code&gt; by prepending it with a &lt;code&gt;^&lt;/code&gt; using a) yanking and b) visual
editing (based on
&lt;a href=&#34;https://thoughtbot.com/blog/how-to-edit-an-existing-vim-macro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; useful
post).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Macro &lt;code&gt;q&lt;/code&gt; hits its target with &lt;code&gt;n&lt;/code&gt;; invoke it quickly for all 12 search
results in the document.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the list below, change &lt;code&gt;.&lt;/code&gt; to &lt;code&gt;)&lt;/code&gt; and words to title case.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;a. ho  
b. hi  
c. he
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Make the reverse changes in the list below&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;a) Ho  
b) Hi  
// a comment  
c) He
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Turn the below lines into a numbered list.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;- first
- second
- third
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;Turn the below list into a numbered list.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;- This is the first bullet - stretching over multiple lines. Well, actually, it didn&#39;t, but now it does.
- The second bullet is long, too. Again, it wasn&#39;t really, but now it is, so we can actually simulate what would happen.
- The third one is short.
- The fourth and final one is long.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;With the cursor anywhere on the first line, start recording and perform the
change on the first line, then either repeat it (a) sequentially or (b) in
parallel. &lt;code&gt;qq&lt;/code&gt;, &lt;code&gt;Ivar&amp;lt;esc&amp;gt;A;&amp;lt;esc&amp;gt;j&lt;/code&gt;, (a) &lt;code&gt;2@q&lt;/code&gt;, (b) &lt;code&gt;Vj:normal@q&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a) Paste the macro content into the buffer and edit it:  &lt;code&gt;&amp;quot;qpI^&amp;lt;esc&amp;gt;&lt;/code&gt;, yank
it back into the q register: &lt;code&gt;&amp;quot;qyy&lt;/code&gt;, clean macro from the buffer &lt;code&gt;dd&lt;/code&gt;. b)
Redefine the macro content directly using &lt;code&gt;let&lt;/code&gt; command by opening the
register &lt;code&gt;:let @q=&#39;&lt;/code&gt;, pasting the current contents &lt;code&gt;&amp;lt;c-r&amp;gt;&amp;lt;c-r&amp;gt;q&lt;/code&gt;, adding &lt;code&gt;^&lt;/code&gt;
at the beginning, and adding &lt;code&gt;&#39;&lt;/code&gt; and press enter to close the quote and
finish editing the macro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;22@q&lt;/code&gt;. Explanation: Because &lt;code&gt;q&lt;/code&gt; uses &lt;code&gt;n&lt;/code&gt; to hit its targets, it will
automatically abort once there are no more results. We can thus avoid
counting matches and simply use a number that&amp;rsquo;s comfortably above the number
of matches. 22 is convenient because, on my keyboard, it&amp;rsquo;s the same key as
@.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Start with cursor anywhere on first line of list, record macro:
&lt;code&gt;qq0f.r)w~jq&lt;/code&gt;, replay macro: &lt;code&gt;22@q&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Start with cursor anywhere on first line of list, record macro:
&lt;code&gt;qq0f.r)w~q&lt;/code&gt;, replay macro: &lt;code&gt;V}:normal @q&lt;/code&gt;. Discussion: Executing the macro
in series as in the previous exercise would abort at the line of the
comment, so we need to execute it in parallel. As a result, there is no need
to move to next line after performing the changes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Start anywhere on the first line, then instantiate the counter: &lt;code&gt;:let i=1&lt;/code&gt;,
record the changes: &lt;code&gt;qq0s&amp;lt;C-r&amp;gt;=i&amp;lt;CR&amp;gt;)&amp;lt;Esc&amp;gt;&lt;/code&gt;, advance the counter: &lt;code&gt;let i+=1&lt;/code&gt;, stop recording: &lt;code&gt;q&lt;/code&gt; and replay: &lt;code&gt;jVj:normal @q&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;My best solution thus far: We need a few preparation steps before we can
execute the macro; first, select and then deselect the area within which you
want to replace list item markers (e.g. &lt;code&gt;vap&lt;/code&gt;, &lt;code&gt;jk&lt;/code&gt;). Second, search for all
list item markers inside that area using &lt;code&gt;/\%V\_^-&lt;/code&gt;, where the &lt;code&gt;\%V&lt;/code&gt; atom
restricts the search to the previous selection, the &lt;code&gt;\_^&lt;/code&gt; atom matches
start-of-line, and &lt;code&gt;-&lt;/code&gt; matches the hyphens used as list item markers.
Finally, initialise the counter using &lt;code&gt;:let i=1&lt;/code&gt;. To record the marco, move
the curser to before the first hypen in the list, then record the motions to
the &lt;code&gt;q&lt;/code&gt; register &lt;code&gt;qq&lt;/code&gt;, move to the first hypehn and replace it while
entering insert mode &lt;code&gt;ncw&lt;/code&gt;, replace it with the counter and add a dot and
exit insert mode &lt;code&gt;&amp;lt;c-r&amp;gt;=i&amp;lt;cr&amp;gt;.jk&lt;/code&gt;, and increment the counter and stop the
recording &lt;code&gt;:let i=i+1q&lt;/code&gt;. Now, you can simply replay the recording in
sequence &lt;code&gt;22@q&lt;/code&gt; and, if needed, reformat the area &lt;code&gt;gvgq&lt;/code&gt;. (I use 22 to
replay the macro for convenience as on my keyboard, 2 is the same key as the
&lt;code&gt;@&lt;/code&gt; symbol, but any number at least as large as the number of remaining
hyphens to be replaced would do).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;patterns&#34;&gt;Patterns&lt;/h2&gt;
&lt;h3 id=&#34;matching-patterns-and-literals&#34;&gt;Matching patterns and literals&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In my &lt;code&gt;.vimrc&lt;/code&gt;, I use &lt;code&gt;set: ignorecase&lt;/code&gt; and &lt;code&gt;set: smartcase&lt;/code&gt; to set the
default search to be case insensitive except when I use an uppercase character
in my pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can use pattern swtiches anywhere in the search pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use &lt;code&gt;\v&lt;/code&gt; for regex search, &lt;code&gt;\V&lt;/code&gt; for verbatim search.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Force case insensitive search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\C&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Force case sensitive search&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\v&lt;/code&gt; (very magic)&lt;/td&gt;
&lt;td&gt;All characters assume special meaning (regex-like search)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\V&lt;/code&gt; (very nomagic)&lt;/td&gt;
&lt;td&gt;No character but &amp;ldquo;&amp;quot; has special meaning (verbatim search)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Capture matched pattern inside and store in numbered silo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;When before &lt;code&gt;()&lt;/code&gt;, don&amp;rsquo;t capture submatch&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;/&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Word boundaries when used with &lt;code&gt;\v&lt;/code&gt; switch&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\zs&lt;/code&gt;/&lt;code&gt;\ze&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Start and end of match&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Useful patterns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Find &lt;code&gt;the&lt;/code&gt; but not words it is a part of (e.g. &lt;code&gt;these&lt;/code&gt;). Solution:
&lt;code&gt;/\v&amp;lt;the&amp;gt;&amp;lt;CR&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In a CSS file, find all hex colour codes. Solution: &lt;code&gt;/\v#(\x{6}|\x{3})&lt;/code&gt;.
Explanation: use &lt;code&gt;\v&lt;/code&gt; for regex search and &lt;code&gt;\x&lt;/code&gt; to capture hexadecimal
characters (equivalent to &lt;code&gt;[0-9a-fA-F]&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find &amp;ldquo;a.k.a.&amp;rdquo; in a file. Solution: &lt;code&gt;/\Va.k.a.&lt;/code&gt;. Explanation: we need &lt;code&gt;\V&lt;/code&gt;
or else &lt;code&gt;.&lt;/code&gt; matches any character and we&amp;rsquo;d also find words like &amp;ldquo;backwards&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check for words that occurr twice in a row. Solution: &lt;code&gt;/\v&amp;lt;(\w+)\_s+\1&amp;gt;&lt;/code&gt;.
Explanation: &lt;code&gt;(\w+)&lt;/code&gt; captures any word, &lt;code&gt;\_s&lt;/code&gt; matches a linebreak or a space
(see &lt;code&gt;h: /\_&lt;/code&gt;), &lt;code&gt;\1&lt;/code&gt; is the reference to the previously captured word, and
&lt;code&gt;&amp;lt;,&amp;gt;&lt;/code&gt; ensure that only two occurrences of the same word get matched and not
also patterns like &amp;ldquo;n&amp;rdquo; in &amp;ldquo;in nord&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reverse the order of all occurrences of &lt;code&gt;Fab Gunzinger&lt;/code&gt; and &lt;code&gt;Fabian Gunzinger&lt;/code&gt;. Solution: &lt;code&gt;/\v(Fa%(b|bian)) (Gunzinger)&lt;/code&gt;; &lt;code&gt;:%s//\2, \1/g&lt;/code&gt;.
Explanation: the first bit captures the short and full version of my first
name, and my last name, without capturing the &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;bian&lt;/code&gt; fragments.  First
and last name can now be references using &lt;code&gt;\1&lt;/code&gt; and &lt;code&gt;\2&lt;/code&gt;, respectively.  The
substitution command finds the last search pattern (since we leave &lt;code&gt;pattern&lt;/code&gt;
blank) and replaces it with my first and last names reversed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find all occurences of &amp;ldquo;Vim&amp;rdquo; that are part of &amp;ldquo;Practical Vim&amp;rdquo;. Solution:
&lt;code&gt;/Practical \zsVim&amp;lt;CR&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find all quoted text. Solution: &lt;code&gt;/\v&amp;quot;\zs[^&amp;quot;]+\ze&amp;quot;&lt;/code&gt;. Explanation: &lt;code&gt;&amp;quot;[^&amp;quot;]+&amp;quot;&lt;/code&gt;
matches quotes followed by one or more occurances of anything but quotes
followed by quotes (this is a useful regex idiom). &lt;code&gt;\zs&lt;/code&gt; and &lt;code&gt;\ze&lt;/code&gt; exclude the
quotes from the match. Note: this only recognises quoted text on the same
line. Note: doesn&amp;rsquo;t work over multiple lines.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Find &lt;code&gt;http://someurl.com/search?=\//&lt;/code&gt;. Solution: Yank pattern into a register,
&lt;code&gt;u&lt;/code&gt; for url, say; &lt;code&gt;/\V&amp;lt;C-r&amp;gt;=escape(@u, getcmdtype().&#39;\&#39;)&amp;lt;CR&amp;gt;&lt;/code&gt;. Explanation:
see tip 79 in PV.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In &lt;em&gt;music amuse fuse refuse&lt;/em&gt; replace &lt;em&gt;us&lt;/em&gt; with &lt;em&gt;az&lt;/em&gt; in &lt;em&gt;amuse&lt;/em&gt; and &lt;em&gt;fuse&lt;/em&gt;
using the substitute command (the point is to practice substitution in a
limited area within a line).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use to the &lt;em&gt;a&lt;/em&gt; at the beginning of &lt;em&gt;amuse&lt;/em&gt;, then use &lt;code&gt;vee&lt;/code&gt; to select the two
words needed, &lt;code&gt;jk&lt;/code&gt; (my mapping for &lt;code&gt;&amp;lt;esc&amp;gt;&lt;/code&gt;) to leave visual mode, and
&lt;code&gt;:s/\%Vus/az/g&lt;/code&gt; to make the substitution in the last selected area: the &lt;code&gt;\%V&lt;/code&gt;
atom is what restricts the substitution to the last selected area.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;search&#34;&gt;Search&lt;/h3&gt;
&lt;h4 id=&#34;within-a-file&#34;&gt;Within a file&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&amp;lt;CR&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Search previous pattern forward&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&amp;lt;CR&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Search previous pattern backwards&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&amp;lt;UP&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Access search history (similar for backward search)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;&amp;lt;C-w&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Autocomplete search field based on preview match&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/{pattern}/e&amp;lt;CR&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Use search offset to jump to end of match (`h:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;search-offset` for more offset options)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gn&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Operate on a complete search match&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In the paragraph below, replace all occurrences of &amp;ldquo;lang&amp;rdquo; or &amp;ldquo;langs&amp;rdquo; with
&amp;ldquo;language&amp;rdquo; or &amp;ldquo;languages&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;learn a lang each year
which lang did you learn?
which lang will you learn?
how many langs do you know?
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;Now repeat the above, but start out by searching without using the search
offset to jump to the end of the word and then make use of it midway through
my search.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Search for the line below each occurrence of &amp;ldquo;lang&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replace all occurrences of &amp;ldquo;PyCode&amp;rdquo; and &amp;ldquo;PythonCode&amp;rdquo; with &amp;ldquo;PYCode&amp;rdquo; or
&amp;ldquo;PYTHONCode&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/lang/&amp;lt;CR&amp;gt;&lt;/code&gt;; &lt;code&gt;ea&lt;/code&gt;; &lt;code&gt;uage&lt;/code&gt;; &lt;code&gt;n.&lt;/code&gt;.  Explanation: the second &lt;code&gt;/&lt;/code&gt; denotes teh
end of the pattern, so from then on we&amp;rsquo;re back in command line mode.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use &lt;code&gt;//e&amp;lt;CR&amp;gt;&lt;/code&gt; to repeat the previous search pattern but with search offset
used.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/lang/+1&lt;/code&gt;. Explanation: &lt;code&gt;+#&lt;/code&gt; in search offset positions the cursor # lines
after the match.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/\vPy(thon)?\C&amp;lt;CR&amp;gt;&lt;/code&gt;; &lt;code&gt;gUgn&lt;/code&gt;; &lt;code&gt;.&lt;/code&gt;. Explanation: &lt;code&gt;gn&lt;/code&gt; applies the pending
operator (&lt;code&gt;gU&lt;/code&gt; in this case) to the current match or, if the cursor isn&amp;rsquo;t on
a match, on the next one. After executing &lt;code&gt;gUgn&lt;/code&gt; for the first time, the
cursor changes the first match and remains there. Once we press &lt;code&gt;.&lt;/code&gt;, the
word under the cursor no longer is a match, so Vim jumps to the next match
and applies the pending &lt;code&gt;gU&lt;/code&gt; operator. Drew Neil calls this the &amp;ldquo;Improved
dot-formula&amp;rdquo;, since we can use &lt;code&gt;.&lt;/code&gt; to achieve &lt;code&gt;n.&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;across-files&#34;&gt;Across files&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There are many options for this. I currently use &lt;code&gt;vim-ripgrep&lt;/code&gt;. The basic
syntax is &lt;code&gt;:Rg &amp;lt;string|pattern&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;string|pattern&amp;gt;&lt;/code&gt; defaulting to the
word under the cursor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim will ist the results in the quickfix window and jump to the first entry
in the window.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find all files that contain the line &lt;em&gt;import s3fs&lt;/em&gt; in (a) the current
directory and (b) in the subdirectory &lt;code&gt;/data&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(a) &lt;code&gt;:Rg &#39;import s3fs&lt;/code&gt;, (b) &lt;code&gt;:Rg &#39;import s3fs&#39; data/&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;substitution&#34;&gt;Substitution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full syntax is &lt;code&gt;:[range]s[ubstitute]/{pattern}/{string}/[flags]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For substitutions across files I use
&lt;a href=&#34;https://github.com/stefandtw/quickfix-reflector.vim&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;quickfix-reflector&lt;/code&gt;&lt;/a&gt;,
which allows for editing the quickfix window, and performs the changes made
there in all files.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Flags:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Substitute all matches on line (global)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Confirm substitution&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Count number of matches instead of substitution&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Reuse flags from previous substitution&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Replacement strings:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert first submatch (similar for {1-9})&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\0&lt;/code&gt;/&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Insert entire matched pattern&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Use string from previous substitution&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\={vim scrip}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Evaluate vim-script expression&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Useful commands&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rerun last substitution (flags aren&amp;rsquo;t remembered)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rerun last substitution and reuse flags&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:g&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Rerun last search globally&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercise:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Replace &lt;code&gt;import helpers.aws as ha&lt;/code&gt; with &lt;code&gt;from helpers import aws&lt;/code&gt; in all
files in the current directory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Decouple pattern matching and substitution (useful for complex patterns that
require trial and error).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use last search pattern in substitute command.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Substitute the highlighted text fragment.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rerun the last line-wise substitution globally.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In a file with columns &amp;ldquo;name&amp;rdquo;, &amp;ldquo;age&amp;rdquo;, &amp;ldquo;height&amp;rdquo;, change order to &amp;ldquo;height&amp;rdquo;,
&amp;ldquo;name&amp;rdquo;, &amp;ldquo;age&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replace &amp;ldquo;Hello&amp;rdquo; in (and only in) &amp;ldquo;Hello World&amp;rdquo; with &amp;ldquo;Hi&amp;rdquo; in all files in my
project.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Find all files and open the quickfix window &lt;code&gt;:Rg &#39;import helpers.aws as ha&#39;&lt;/code&gt;, perform the change in each file inside the quickfix window and save.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/{pattern}&lt;/code&gt; until you get it right (maybe use &lt;code&gt;q/&lt;/code&gt;), then &lt;code&gt;:s//{string}&lt;/code&gt;.
Explanation: leaving {pattern} blank uses last search pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:s/&amp;lt;C-r&amp;gt;//{string}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;*:s//{string}&lt;/code&gt;.  Explanation: with &lt;a href=&#34;https://github.com/nelstrom/vim-visual-star-search&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;vim visual
star&lt;/a&gt; plugin installed,
&lt;code&gt;*&lt;/code&gt; searches for pattern highlighted in visual mode.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;g&amp;amp;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/\v^([^,]), ([^,]), ([^,])$&lt;/code&gt;; &lt;code&gt;:%s//\3, \1, \2&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;First, test pattern in current buffer: &lt;code&gt;/Hello\ze World&amp;lt;CR&amp;gt;&lt;/code&gt;, then search
all files in project and populate quickfix list with files that have a
match: &lt;code&gt;:vimgrep // **/*.txt&lt;/code&gt;, finally: iterate through the files in the
quickfix list to execute the substitute and update commands: &lt;code&gt;:cfdo %s//Hi/gc | update&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;global-commands&#34;&gt;Global commands`&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full syntax: &lt;code&gt;:[range] global[!] /{pattern}/ {cmd}&lt;/code&gt;. Range defaults to the
entire file, leaving the pattern empty uses last search pattern, and command
defaults to print.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A generalised version of the command, useful to operate inside text or code
blocks, is &lt;code&gt;:g/{start} .,{finish} [cmd]&lt;/code&gt;, which applies the command to each
range of lines that begins with {start} and ends with {finish}. See CSS
sorting example below.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g[lobal]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Global command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;v[global]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Invert global&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g[lobal]!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Invert global&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Delete all lines that contain &amp;ldquo;Hi&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Keep only lines that contain &amp;ldquo;Hi&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Print all lines that contain &amp;ldquo;Hi&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Yank all lines that contain &amp;ldquo;TODO&amp;rdquo; into register a.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Glance at markdown file structure (create a table of contents).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Glance at top-level markdown titles.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Glance at markdown top and secondary level titles.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alphabetically sort properties inside each rule of a CSS file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:g/Hi/d&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:v/Hi/d&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:g/Hi&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;qaq&lt;/code&gt; (to empty register); &lt;code&gt;:g/TODO/yank A&lt;/code&gt;. Explanation: need capital &lt;code&gt;A&lt;/code&gt;
to append to rather than overwrite register.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;g/^#&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:g/^# &lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:g/\v^#(#)? &lt;/code&gt;. Explanation: Need &lt;code&gt;\v&lt;/code&gt; so that parentheses have magic
characteristics (otherwise I&amp;rsquo;d have to escape them, which is cumbersome),
need &lt;code&gt;?&lt;/code&gt; &amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:g/{/ .+1,/}/-1 sort&lt;/code&gt;. Explanation: &lt;code&gt;/{/&lt;/code&gt; is the pattern of the global
command and searches for all lines that contain an &lt;code&gt;{&lt;/code&gt;. &lt;code&gt;.+1,/}/-1&lt;/code&gt; is the
range of the Ex command, specified as from the current line until the next
line that contains a closing curly bracket.  The offsets narrow the range to
exclude the lines with curly brackets. The current line address here stands
for each line in turn that matches the &lt;code&gt;/{/&lt;/code&gt; pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;folds&#34;&gt;Folds&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Open all folds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zM&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Close all folds&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;leader&amp;gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle fold under cursor (mapping of &lt;code&gt;za&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;mappings&#34;&gt;Mappings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;General syntax: &lt;code&gt;{cmd} {attr} {lhs} {rhs}&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mapping process: define the sequence of keys to be mapped, decide the editing
mode in which the mapping will work, find a suitable and free key sequence.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Understanding &lt;code&gt;noremap&lt;/code&gt; mappings: by default, vim mappings are recursive
(i.e.  if a is mapped to b and b to c, then a is really mapped to c because b
will be expanded on the rhs. The second mapping could be part of a plugin so
that I&amp;rsquo;m not even aware of it). This behaviour is set with the &lt;code&gt;remap&lt;/code&gt;
option.  To define non-recursive mappings, we can use the &lt;code&gt;noremap&lt;/code&gt; mappings.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:nmap {char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;List all normal mode mappings starting with {char}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:verbose nmap {char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;As above, but shows location where maps are defined&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;editing&#34;&gt;Editing&lt;/h2&gt;
&lt;h3 id=&#34;autocompletion&#34;&gt;Autocompletion&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Trigger autocompletion and navigate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-e&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dismiss autocomplete window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-n&amp;gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Filter suggestions as we type&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-k&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dictionary lookup (requires spellchecker on - &lt;code&gt;yos&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-l&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Autocomplete entire line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-f&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Autocomplete filename (relative to pwd)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;I&amp;rsquo;ve experimented with &lt;code&gt;youcompleteme&lt;/code&gt;, which I deleted again because its too
clunky for my taste. In case I want to install again in the future, this might
be helpful:
&lt;a href=&#34;https://github.com/ycm-core/YouCompleteMe/wiki/FAQ#ycm-does-not-work-with-my-anaconda-python-setup&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Often&lt;/a&gt;
doesn&amp;rsquo;t work with Anaconda Python, and I seem to be one of those cases.
Followed the suggestion in the link. I first tried compiling with
&lt;code&gt;/usr/bin/python3&lt;/code&gt;, but this didn&amp;rsquo;t work. I then tried
&lt;code&gt;/usr/local/bin/python3.9&lt;/code&gt;, following
&lt;a href=&#34;https://stackoverflow.com/questions/62546912/youcompleteme-completed-failed&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt;,
which seems to have worked.&lt;/p&gt;
&lt;p&gt;### Spell checking&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;yos&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle spell checker (uses &lt;code&gt;vim-unimpaired&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]s&lt;/code&gt;/&lt;code&gt;[s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to next/previous misspelled word&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;z=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Suggest corrections&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[n]z=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Correct word with nth suggestion&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Add current word to spell file (mnem: &amp;ldquo;good&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zw&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Remove current word from spell file (mnem: &amp;ldquo;wrong&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zug&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Revert &lt;code&gt;zg&lt;/code&gt; or &lt;code&gt;zw&lt;/code&gt; command for current word&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;### Formatting&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gq{motion}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Formats text, defaults to wrapping long lines.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;### Case coercion&lt;/p&gt;
&lt;p&gt;Uses &lt;a href=&#34;https://github.com/tpope/vim-abolish&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;vim-abolish&lt;/a&gt;, which deals with word
variants and provides powerful searching, grepping, substitution and case
coercion.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;crs&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Coerce to &lt;code&gt;snake_case&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;crc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Coerce to &lt;code&gt;camelCase&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;crm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Coerce to &lt;code&gt;MixedCase&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cru&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Coerce to &lt;code&gt;UPPER_CASE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cr-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Coerce to &lt;code&gt;dash-case&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cr.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Coerce to &lt;code&gt;dot.case&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cr&amp;lt;space&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Coerce to &lt;code&gt;space case&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;crt&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Coerce to &lt;code&gt;Title Case&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Exercises:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Replace all occurrences of &lt;em&gt;child[ren]&lt;/em&gt; with &lt;em&gt;adult[s]&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replace all occurrences of &lt;em&gt;man&lt;/em&gt; with &lt;em&gt;dog&lt;/em&gt; and vice versa.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:%S/child{,ren}/adult{,s}/g&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:%S/{man,dog}/{dog,man}/g&lt;/code&gt;. Discussion: Don&amp;rsquo;t use whitespace after comma,
as Vim would treat it as part of the search/replacement pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;comments&#34;&gt;Comments&lt;/h3&gt;
&lt;p&gt;Uses &lt;a href=&#34;https://github.com/tpope/vim-commentary&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;vim-commentary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Main commands:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gc{motion}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{Visual}gc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[range]Commentary&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;language-and-program-specific-settings&#34;&gt;Language and program specific settings&lt;/h2&gt;
&lt;h3 id=&#34;git&#34;&gt;Git&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;I use basic commands from vim-fugitive&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Execute makefiles using &lt;code&gt;:make&lt;/code&gt; (Set up quicklist such that I can jump to
errors directly, this currently doesn&amp;rsquo;t work. Probably requires some
additional setup to recognise Python errors.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I use Ctags to navigate my codebase. I&amp;rsquo;ve followed Tim Pope&amp;rsquo;s
&lt;a href=&#34;https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;approach&lt;/a&gt; to
set this up. For newly initialised or cloned directories, this setup
automatically creates hooks and indexes the code with Ctags. For existing
directories, you need to run &lt;code&gt;git init&lt;/code&gt; to copy the hook templates into the
local &lt;code&gt;.git/hooks&lt;/code&gt;, and then &lt;code&gt;git ctags&lt;/code&gt; to index the code.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ctag commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-]&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to definition of keyword under cursor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&amp;lt;C-]&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;As above, but select definition if there are multiple&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:tag {keyword}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Jump to definition of keyword&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:tjump {keyword}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;As above, but select definition if there are multiple&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;Look into using &lt;code&gt;matchit&lt;/code&gt; or something similar for faster code navigation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;latex&#34;&gt;Latex&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;You can use &lt;code&gt;&amp;lt;C-N&amp;gt;&lt;/code&gt; completion for words that already appear in one of the
open buffers. This is especially useful for bibliography completion: just open
the .bib file in another buffer and &lt;code&gt;&amp;lt;C-N&amp;gt;&lt;/code&gt; will provide a list of
available keys.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I use &lt;a href=&#34;https://github.com/lervag/vimtex&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;vimtex&lt;/a&gt;, with &lt;code&gt;Skim&lt;/code&gt; as my viewer. In
vimtex, most shortcuts use &lt;code&gt;localleader&lt;/code&gt;, which, by default, is set to &lt;code&gt;\&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vimtex commands:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\ll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Toggle continuous compilation using &lt;code&gt;latexmk&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\lk&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Kill compilation process&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\lc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Clear auxiliary files&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\lt&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Show table of contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\ds{c/e/$/d}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Delete surrounding command/environment/math env/delimiter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\cs{c/e/$/d}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Change surrounding command/environment/math env/delimiter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:VimtexDocPackage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Show docs for argument under cursor or supplied package&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:VimtexCountWords&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Count words in document&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-o&amp;gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Citation completion (inside &lt;code&gt;\cite{&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;To next section&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;To next environment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;To next math zone&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;]r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;To next frame&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Vimtex text objects:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Effect&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Command&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Delimiters (e.g. &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Environment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Inline math environment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;P&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Sections&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Items&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;obscurities&#34;&gt;Obscurities&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;plug&amp;gt;&lt;/code&gt; Allows authors of plugins to pre-map commands to so users can easily
map them to their preferred keys. E.g. &lt;code&gt;&amp;lt;plug&amp;gt;(test)&lt;/code&gt; might stand for a very
long sequence of commands. To map that sequence to &lt;code&gt;&amp;lt;leader&amp;gt;t&lt;/code&gt;, I can simply
use &lt;code&gt;nmap &amp;lt;leader&amp;gt;t &amp;lt;plug&amp;gt;(test)&lt;/code&gt;.
&lt;a href=&#34;https://vi.stackexchange.com/a/31013&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;This&lt;/a&gt; SE answer explains it very
clearly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;troubleshooting&#34;&gt;Troubleshooting&lt;/h2&gt;
&lt;h3 id=&#34;css-indent-not-working&#34;&gt;CSS indent not working&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Vim recognised css files, but used my global indent of 4 spaces rather than a
file-type specific indent of 2 spaces.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;h: filetype&lt;/code&gt; notes that filetype detection files are located in the runtime
path. Going there, I found the &lt;code&gt;ftplugins&lt;/code&gt; folder that contains the default
file settings. Looking at &lt;code&gt;css.vim&lt;/code&gt; makes clear that it doesn&amp;rsquo;t set any
tabstop settings, which explains why the defaults were used.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Googling something along the lines of &amp;ldquo;custom filetype indent vim&amp;rdquo; let me to
&lt;a href=&#34;https://stackoverflow.com/a/159066&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; SO answer, which helpfully links
to &lt;code&gt;h: filetype-plugins&lt;/code&gt;. Once there, it was easy to find the relevant
section, &lt;code&gt;ftplugin-overrule&lt;/code&gt; that documents how to add custom filetype
settings. This is what I did, and it worked like a charm.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sources&#34;&gt;Sources&lt;/h2&gt;
&lt;p&gt;This cheat sheet started out as a summary of Drew Neil&amp;rsquo;s phenomenal &lt;a href=&#34;https://pragprog.com/titles/dnvim2/practical-vim-second-edition/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Practical
Vim&lt;/a&gt;, which I
can&amp;rsquo;t recommend enough as a start to learning Vim seriously.&lt;/p&gt;
&lt;p&gt;Other resources I found useful:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://vim.fandom.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_2%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vim Fandom mappings
tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dough Black&amp;rsquo;s &lt;a href=&#34;https://dougblack.io/words/a-good-vimrc.html#fold&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;good vimrc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Using help: &lt;a href=&#34;https://vim.fandom.com/wiki/Learn_to_use_help&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://vim.fandom.com/wiki/Learn_to_use_help&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/romainl/idiomatic-vimrc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Idiomatic VIM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Awesome vimrc: &lt;a href=&#34;https://github.com/amix/vimrc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/amix/vimrc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vim as Python IDE: &lt;a href=&#34;https://realpython.com/vim-and-python-a-match-made-in-heaven/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://realpython.com/vim-and-python-a-match-made-in-heaven/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Makefiles</title>
      <link>https://fabiangunzinger.github.io/post/makefiles/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/makefiles/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A makefile is a data base that tells the &lt;code&gt;make&lt;/code&gt; utilit how to recompile a
system. In the default use case, &lt;code&gt;$: make &amp;lt;filename&amp;gt;&lt;/code&gt; checks whether &lt;code&gt;filename&lt;/code&gt; is out of date and, if so, recompiles it. In the way I use makefiles, &lt;code&gt;$: make &amp;lt;rule&amp;gt;&lt;/code&gt;
executes a predefined rule to accomplish a certain task like cleaning a
particular dataset.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rules consist of a target (the name of a file to be modified), prerequisites
(other files on which the target depends on), and commands to be run in order
to update the traget based on changes in the prerequisites.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A rule tells &lt;code&gt;make&lt;/code&gt; when a target is out of date and how to update it. A
target is out of date if it doesn&amp;rsquo;t exist or is older then one of its
prerequisite files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$: make&lt;/code&gt; executes the first specified rule, &lt;code&gt;$: make &amp;lt;rule&amp;gt;&lt;/code&gt; executes a
particular rule.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A normal prerequisite makes both an &lt;em&gt;order statement&lt;/em&gt; and a &lt;em&gt;dependency statement&lt;/em&gt;:
the order statement ensures that all commands needed to produce the
prerequisete are fully executed before any commands to produce the target,
while the dependency statement ensures that the target is updated every time a
prerequisite changes. Occasionally, we want a prerequisite to invoke the order without the
dependency statement (i.e. target is not udpated when the prerequisite
changes, but when target is being updated, then the prerequisite commandas are
run first). We can do this by writing the rule as &lt;code&gt;target: normal-prerequisites | order-only-prerequisites&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt; does its work in two phases: during the &lt;em&gt;read-in&lt;/em&gt; phase, it reads the
makefile and internalises variables and rules to construct a dependency graph
of all targets and their prerequisies; during the &lt;em&gt;target-update&lt;/em&gt; phase, it
determines what rules to update in what order and executes the commandas to do
so.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As a result, variable and function expansion can happen either &lt;em&gt;immediately&lt;/em&gt;
(during the read-in phase) or &lt;em&gt;deferred&lt;/em&gt; (after the read-in phase), and gives
rise to two flavours of variables: &lt;em&gt;recursively expanded variables&lt;/em&gt;, defined by
&lt;code&gt;varname = value&lt;/code&gt; are expanded at the time the variable is substituted during
the target-update phase. Before that point, &lt;code&gt;varname&lt;/code&gt; contains the content of
&lt;code&gt;value&lt;/code&gt; verbatim (e.g. if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;$(othervar)&lt;/code&gt;, then that last string is
the value of &lt;code&gt;varname&lt;/code&gt;). In contrast, &lt;em&gt;simply expanded variables&lt;/em&gt;, defined by
&lt;code&gt;varname := value&lt;/code&gt; is expanded immediately when the variable is defined during
the read-in phase (and &lt;code&gt;varname&lt;/code&gt; would be bound to the value of &lt;code&gt;othervar&lt;/code&gt; in
the above example).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To define a variable containing all csv files in a directory, do &lt;code&gt;csvs := $(wildcard *.csv)&lt;/code&gt;. The &lt;code&gt;wildcard&lt;/code&gt; function is needed here so that the
wildcard gets expanded during function creation (as opposed to creating the
variable with value &lt;code&gt;*.csv&lt;/code&gt;). I could also create a list
containing the same files but with a parquet extensions like so: `parqs :=
$(patsubst %.csv,%.parquet,$(wildcard *.csv)).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Automatic variables: &lt;code&gt;$^&lt;/code&gt; is a list of all prerequisites, &lt;code&gt;$@&lt;/code&gt; is the target,
&lt;code&gt;$&amp;lt;&lt;/code&gt; the first prerequisite.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If a target is an action to be performed rather than a file to be updated,
then it&amp;rsquo;s called a &lt;code&gt;phony target&lt;/code&gt;. In this case, telling &lt;code&gt;make&lt;/code&gt; that we&amp;rsquo;re
using a phone target explicitly by prepending the rule with a line like
&lt;code&gt;.PHONY : nameofrule&lt;/code&gt; is useful for two reasons: &lt;code&gt;make&lt;/code&gt; doesn&amp;rsquo;t think of a
file called &lt;code&gt;nameofrule&lt;/code&gt; as the target (which, if it did, would mean that our
rule never gets run because it has no prerequisites so that &lt;code&gt;make&lt;/code&gt; would think
of &lt;code&gt;nameofrule&lt;/code&gt; as always up to date) and it doesn&amp;rsquo;t check for implicit
commands to update the target, which improves performance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Commands begin with a tab and, unless specified otherwise, are executed by
&lt;code&gt;bin/sh&lt;/code&gt;. You can set a different shell by changing the value of the &lt;code&gt;SHELL&lt;/code&gt;
variable (I usually use &lt;code&gt;SHELL := /bin/bash&lt;/code&gt;. Each line that begines with a tab and appears within a rule context
(anything between the start of one rule and another) is interpreted as a
command and sent to the shell.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The only thing &lt;code&gt;make&lt;/code&gt; does with commands is to check for &lt;code&gt;\&lt;/code&gt; before newline,
and for variables to expand (if you want &lt;code&gt;$&lt;/code&gt; to appear in the command, use
&lt;code&gt;$$&lt;/code&gt;). To prevent &lt;code&gt;make&lt;/code&gt; from echoing a command, prepend it with &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Prepend a command with &lt;code&gt;-&lt;/code&gt; if you want &lt;code&gt;make&lt;/code&gt; to continue regardless of
errors. This can be useful for commands like &lt;code&gt;-rm tempfile.csv&lt;/code&gt;, where you
probaby want to continue even if the file didn&amp;rsquo;t exist and could thus not be
removed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;best-practices&#34;&gt;Best practices&lt;/h2&gt;
&lt;p&gt;Define a phony target:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.PHONY: clean
clean:
    rm *.csv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Make &lt;code&gt;$: make&lt;/code&gt; run all rules:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.PHONY: all
all : rule1 rule2

.PHONY: rule1
rule1:
    mkdir hello

.PHONY: rule2
rule2:
    rm -rf hello
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Clean code</title>
      <link>https://fabiangunzinger.github.io/post/clean-code/</link>
      <pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/clean-code/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;When people look under the hood, we want them to be impressed by the neatness,
consistency, and attention to detail [&amp;hellip;] If instead they see a scrambled
mass of code that looks like it was written by a bevy of drunken sailors, then
they are likely to conclude that the same inattention to detail pervades every
other aspect of the project. Robert Martin, &lt;em&gt;Clean Code&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;definitions&#34;&gt;Definitions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A design pattern is a general repeatable solution to a frequently occuring
problem.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An idiom is the translation of a design pattern into code using the language
clearly and correctly.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;principles&#34;&gt;Principles&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Don&amp;rsquo;t repeat yourself. Collect often used pieces of code in a function of
class for reuse. Don&amp;rsquo;t copy and paste more than once.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Single Responsibility Principle (SRP): a class or module should only have a
single reason to change &amp;ndash; it should be responsible to a single actor that can
demand change. Example: an employee class that produces outputs for the
finance and HR departments violates the principle, as both the CFO and the CHO
might demand changes that then unintenionally affects the output seen by the
other. Solution: Separate code that different actors depend on. Corollary:
don&amp;rsquo;t reuse a function for two different outputs just because it does they
require the same task, only reuse the function for two outputs that require
the same task &lt;em&gt;and&lt;/em&gt; have a common owner. Example, don&amp;rsquo;t if both HR and finance
need to calculate regular hours, don&amp;rsquo;t use the same function, as the CFO might
want to change the definition of regular hours but HR doesn&amp;rsquo;t.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open-Closed Principle (OCP): classes should be open for extension and closed
for modification. (We should easily be able to add new functionality without
having to change existing functionality.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use names to make the context explicit (e.g. &amp;ldquo;for user in users&amp;rdquo; is explicit,
&amp;ldquo;for i in list&amp;rdquo; isn&amp;rsquo;t).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get to proof of concept asap.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;You ain&amp;rsquo;t gonna need it&amp;rdquo; (YAGNI). Don&amp;rsquo;t add functionality before it&amp;rsquo;s really
necessary.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;names&#34;&gt;Names&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Choose names that make clear what a thing is, what it does, and how it is used.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use plain and unabbreviated words.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Omit needless words like &amp;ldquo;get&amp;rdquo; or &amp;ldquo;calculate&amp;rdquo;, but remember that &amp;ldquo;terseness
and obscurity are the limits where brevity should
&lt;a href=&#34;https://docs.python-guide.org/writing/structure/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stop&lt;/a&gt;&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use verbs or verb phrases for functions, nouns for classes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Choose names of variables in proportion to their scope.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Whenever appropriate, use names from the solution domain (e.g. computer or
data science) or the problem domain (e.g. personal finance) otherwise.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;functions&#34;&gt;Functions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Functions should do one thing and one thing only and should do it well. (It&amp;rsquo;s
not always obvious what &amp;ldquo;one thing&amp;rdquo; is, use your judgement.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make functions as short as possible to make it obvious how they work and what
they are for.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Most often, blocks inside flow control statements should be one line long -
calls to transparently named functions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A good function interface allows the user to do what they need without having
to worry about unnecessary details. Hence: ask for the minimally required
number of intuitive arguments and return the expected output.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write pure functions. A function is pure when it is idempotent (returns the
same output for a given input) and has no side-effects.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;comments-and-docstrings&#34;&gt;Comments and docstrings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Don&amp;rsquo;t comment bad code &amp;ndash; rewrite it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add docstrings to functions unless &amp;ndash; following
&lt;a href=&#34;https://google.github.io/styleguide/pyguide.html#383-functions-and-methods&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google&lt;/a&gt;
&amp;ndash; they are helpers, short and obvious.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;modules&#34;&gt;Modules&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use the &lt;code&gt;module.function&lt;/code&gt; idiom (i.e. use &lt;code&gt;import module&lt;/code&gt; rather than &lt;code&gt;from module import function&lt;/code&gt;) in all but the simplest projects.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;systems&#34;&gt;Systems&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kent Beck&amp;rsquo;s four rules for a simply designed system (in order or importance):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;It runs all tests&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Contains no duplication&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Expresses the intent of the programmer (choose expressive names, keep
functions and classes small, use standard nomenclature, good unit tests)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Minimises the number of classes and methods&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oreilly.com/library/view/clean-code-a/9780136083238/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clean Code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.python-guide.org/writing/style/#code-style&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Hitchhiker&amp;rsquo;s Guide to Python, code
style&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ipython-books/cookbook-2nd/blob/master/chapter02_best_practices/07_high_quality.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IPython cookbook, writing high-quality Python
code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://google.github.io/styleguide/pyguide.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google style guide&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jeffknupp.com/blog/2018/10/11/write-better-python-functions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jeff Knupp
post&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://greenteapress.com/wp/think-python-2e/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Think Python&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python tricks</title>
      <link>https://fabiangunzinger.github.io/post/python-tricks/</link>
      <pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/python-tricks/</guid>
      <description> &lt;iframe
       src=&#34;./python-tricks.html&#34;
       width=&#34;90%&#34;
       height=&#34;2200&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Python modules and packages</title>
      <link>https://fabiangunzinger.github.io/post/modules-and-packages/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/modules-and-packages/</guid>
      <description>&lt;h2 id=&#34;modules&#34;&gt;Modules&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;module&lt;/em&gt; is a file that contains definitions intended for reuse in a script
or an interactive session.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Calling &lt;code&gt;import module&lt;/code&gt; for the first time does three things: 1) create a new
namespace that acts as the global namespace for all objects defined in module,
2) execute the entire module, 3) create a name &amp;ndash; identical to the module name
&amp;ndash; within the caller namespace that references to the module. This can be used
to access module objects in the caller namespace as &lt;code&gt;module.object&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Calling &lt;code&gt;from module import symbol&lt;/code&gt; imports &lt;code&gt;symbol&lt;/code&gt; into the current
namespace. However, the global namespace for &lt;code&gt;symbol&lt;/code&gt; (if it&amp;rsquo;s a function)
always remains the namespace in which it was defined, not the caller&amp;rsquo;s
namespace.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regardless of what variant of the import statement is being used to import
contents from a module, all of the module&amp;rsquo;s statements will be initialised the
first time (and only the first time) the module name is encountered in an
import statement (more details
&lt;a href=&#34;https://docs.python.org/3/tutorial/modules.html#more-on-modules&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;One reason &lt;code&gt;from module import *&lt;/code&gt; is generally discouraged is that it directly
imports all the module&amp;rsquo;s objects into the caller&amp;rsquo;s namespace, which is often
said to cluter it up. Especially when importing large modules this makes
sense, as it&amp;rsquo;s much cleaner to keep objects defined in imported modules in
eponymous namespaces and accessing them via &lt;code&gt;module.object&lt;/code&gt;, which immediately
makes clear where object comes from and can help greatly with debugging.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;One implication of all the above is that as a developer, you don&amp;rsquo;t have to
worry about clashing variable names between modules, as they are each stored
in their own namespace, and accessed via &lt;code&gt;moduleA.foo&lt;/code&gt; and &lt;code&gt;moduleB.foo&lt;/code&gt; in
the caller namespace.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When we import a module &lt;code&gt;foo&lt;/code&gt;, the interpreter first searches for a built-in
module and, if none is found, searches a list of directories given the
variable &lt;code&gt;sys.path&lt;/code&gt;. &lt;code&gt;sys.path&lt;/code&gt; contains the directory of the input script,
the variable &lt;code&gt;PYTHONPATH&lt;/code&gt;, and installation-dependent defaults. I can
manipulate &lt;code&gt;sys.path&lt;/code&gt; using standard list operations; to add a directory, use
&lt;code&gt;sys.path.append(&#39;dirname&#39;)&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A common usecase of the above for me is to make a package available to Jupyter
Notebooks. By default, a notebook&amp;rsquo;s &lt;code&gt;sys.path&lt;/code&gt; contains the folder the noteook
is located in and a bunch of conda managed directories linked to my running
Conda environment. To make available a package that lives in the project root
directory, just do
&lt;code&gt;sys.path.append(&#39;/Users/fgu/dev/projectname/packagename&#39;)&lt;/code&gt;. I can then
reference modules from the package using &lt;code&gt;from packagename import module&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use &lt;code&gt;dir(modulename)&lt;/code&gt; to list all names defined in &lt;code&gt;modulname&lt;/code&gt;, or &lt;code&gt;dir()&lt;/code&gt; to
list all names that are currently defined.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;running-a-module-as-a-script&#34;&gt;Running a module as a script&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For relative imports to work as described, for instance, here and in Chapter 8
in Python Essential References and in recipees 10.1 and 10.3 in the Python
Cookbook, the file into which you import has itself to be a module rather than
a top-level script. If it&amp;rsquo;s the latter, it&amp;rsquo;s name will be main and it won&amp;rsquo;t be
considered part of a package, regardless of where on the file system it is
saved. Generally, for a file to be considered part of a package, it needs to
nave a dot (.) in its name, as in package.submodule.modulename.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To import modules into a main script, one (somewhat unideal) solution is to
add the absolute path to the package to &lt;code&gt;sys.path&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;packages&#34;&gt;Packages&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Packages are collections of modules. They help structure Python&amp;rsquo;s module
namespace by using dotted module names. E.g. &lt;code&gt;a.b&lt;/code&gt; refers to submodule &lt;code&gt;b&lt;/code&gt; in
package &lt;code&gt;a&lt;/code&gt;. Thus, just as the use of modules alleviates worries about
clashing global variable names between modules, using a package alleviates
worries about clashing module between multi-module packages.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sources&#34;&gt;Sources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python docs -
Modules&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/14132789/relative-imports-in-python-2-7/14132912#14132912&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SO answer on relative imports for
scripts&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Numpy essentials</title>
      <link>https://fabiangunzinger.github.io/post/numpy-essentials/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/numpy-essentials/</guid>
      <description> &lt;iframe
       src=&#34;./numpy-essentials.html&#34;
       width=&#34;90%&#34;
       height=&#34;13300px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://fabiangunzinger.github.io/post/linux/</link>
      <pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/linux/</guid>
      <description>&lt;h2 id=&#34;getting-help-and-finding-stuff&#34;&gt;Getting help and finding stuff&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;man &amp;lt;command&amp;gt;&lt;/code&gt; opens the manual for &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;man -k &amp;lt;search term&amp;gt;&lt;/code&gt; lists all commands with &lt;code&gt;&amp;lt;search term&amp;gt;&lt;/code&gt; in the manual
pages.&lt;/li&gt;
&lt;li&gt;Search inside manual works as in vim.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;basics&#34;&gt;Basics&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A process is a running instance of a program.&lt;/li&gt;
&lt;li&gt;Everything is a fiele (the keyboard is read-only, the screen write only)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;misc-useful-stuff-i-use-often&#34;&gt;Misc. useful stuff I use often&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ln -s [OPTIONS] FILE LINK&lt;/code&gt;. Create a soft link for FILE at LINK. If you use
&lt;code&gt;.&lt;/code&gt; for LINK, a link with the same name as FILE will be created in the current
location.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In mac terminal, &lt;code&gt;pbcopy&lt;/code&gt; and &lt;code&gt;pbpaste&lt;/code&gt; allow you to copy from and paste to
the terminal. I often use &lt;code&gt;pwd | pbcopy&lt;/code&gt; to get a directory path for use
elsewhere, and &lt;code&gt;pbpaste &amp;gt; .gitignore&lt;/code&gt; to create a gitignore file from a
template (e.g. from gitignore.io).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;file-handling&#34;&gt;File handling&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file&lt;/code&gt; lists file type of all files in a directory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wc&lt;/code&gt; returns the number of words, lines, and bytes of the input file. Options
-w, -l, -c return any one of those counts, -m returns the number of
characters. (Remember difference between &lt;code&gt;wc -w &amp;lt;filename&amp;gt;&lt;/code&gt; and &lt;code&gt;wc -w &amp;lt; &amp;lt;filename&amp;gt;&lt;/code&gt;: former prints file name, latter redirects file content to
command anonymously, so prints result only.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cut&lt;/code&gt; print certain columns of input file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed&lt;/code&gt; (stream edit) offers vim-like search and replace on data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uniq&lt;/code&gt; removes duplicates from data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;egrep&lt;/code&gt; for regex-based filtering.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;processes&#34;&gt;Processes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;top&lt;/code&gt; to list most memory-intensive processes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps&lt;/code&gt; lists processes running in current terminal, use -aux option to print all
running processes (use | grep to filter output).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kill [signal] &amp;lt;process id&amp;gt;&lt;/code&gt; to kill a process, use -9 signal to force if
required.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl-z&lt;/code&gt; to move current job to background, &lt;code&gt;jobs&lt;/code&gt; to list running background
jobs, &lt;code&gt;fg &amp;lt;job id&amp;gt;&lt;/code&gt; to move job to foreground.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bash-scripting&#34;&gt;Bash scripting&lt;/h2&gt;
&lt;p&gt;Variables&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;&lt;/code&gt; interpret all content literally, &lt;code&gt;&amp;quot;&lt;/code&gt; allow for variable substitution.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$( command )&lt;/code&gt; saves command output into a variable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export var&lt;/code&gt; makes &lt;code&gt;var&lt;/code&gt; available to child process.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/stdin&lt;/code&gt; reads input from pipe.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Arithmetic&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt; assigns result of expression to a variable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr&lt;/code&gt; prints result of expression.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(( expression ))&lt;/code&gt; returns the result of expression.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${#var}&lt;/code&gt; returns the length of &lt;code&gt;var&lt;/code&gt; in characters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Functions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function_name () { &amp;lt;commands&amp;gt; }&lt;/code&gt;
is the basic format (there is also &lt;code&gt;function function_name {&lt;/code&gt;, but I prefer this.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;permissions&#34;&gt;Permissions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Three actions: &lt;code&gt;r&lt;/code&gt; (read), &lt;code&gt;w&lt;/code&gt; (write), &lt;code&gt;x&lt;/code&gt; (execute).&lt;/li&gt;
&lt;li&gt;Three types of users: owner or user (u), group (g), and others (o). (a)
applies to all types.&lt;/li&gt;
&lt;li&gt;Permission info is 10 characters long: first character is file type (&lt;code&gt;-&lt;/code&gt; for
file, &lt;code&gt;d&lt;/code&gt; for directory), the remaining ones are rwx permissions for owner,
group, and others, with letter indicating permission on, hyphen indicating
permission off.&lt;/li&gt;
&lt;li&gt;Changing persmission: &lt;code&gt;chmod &amp;lt;user type&amp;gt;&amp;lt;add or remove&amp;gt;&amp;lt;permission type&amp;gt;&lt;/code&gt;.
User type defaults to a.  Example: &lt;code&gt;chmod g+w&lt;/code&gt; adds write permission for
group, &lt;code&gt;chmod u-x&lt;/code&gt; removes execute permission for owner, &lt;code&gt;chmod a+rwx&lt;/code&gt; grants
all permission to everyone.  &lt;code&gt;chmod&lt;/code&gt; stands for change file mode bits.&lt;/li&gt;
&lt;li&gt;Shortcuts: Remember the following:&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Octal&lt;/th&gt;
&lt;th&gt;Binary&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;This is useful because we can use the binary numbers to refer to rwx and the
Octal ones as shortcuts (e.g. 5 is r-x). Further using the order of users as
ugo, and using one Octal shortcut for each user, we can quickly set
permissions for all users (e.g. 753 is rwxr-x-wx).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Directory permissions: r means you can read content (e.g. do ls), w means you
can write (e.g. create files or subdirectories), and x means you can enter
(e.g. cd).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sources&#34;&gt;Sources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ryanstutorials.net/bash-scripting-tutorial/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ryan&amp;rsquo;s bash-scripting tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ryanstutorials.net/bash-scripting-tutorial/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ryan&amp;rsquo;s linux tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Idiomatic Python</title>
      <link>https://fabiangunzinger.github.io/post/idiomatic-python/</link>
      <pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/idiomatic-python/</guid>
      <description> &lt;iframe
       src=&#34;./idiomatic-python.html&#34;
       width=&#34;90%&#34;
       height=&#34;2200&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Python functions</title>
      <link>https://fabiangunzinger.github.io/post/python-functions/</link>
      <pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/python-functions/</guid>
      <description> &lt;iframe
       src=&#34;./python-functions.html&#34;
       width=&#34;90%&#34;
       height=&#34;10500&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Documenting sample selection</title>
      <link>https://fabiangunzinger.github.io/post/documenting-sample-selection/</link>
      <pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/documenting-sample-selection/</guid>
      <description> &lt;iframe
       src=&#34;./documenting-sample-selection.html&#34;
       width=&#34;90%&#34;
       height=&#34;11000px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Python decorators</title>
      <link>https://fabiangunzinger.github.io/post/python-decorators/</link>
      <pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/python-decorators/</guid>
      <description> &lt;iframe
       src=&#34;./python-decorators.html&#34;
       width=&#34;90%&#34;
       height=&#34;10000&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Matplotlib</title>
      <link>https://fabiangunzinger.github.io/post/matplotlib/</link>
      <pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/matplotlib/</guid>
      <description> &lt;iframe
       src=&#34;./matplotlib.html&#34;
       width=&#34;100%&#34;
       height=&#34;6700px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Machine learning basics</title>
      <link>https://fabiangunzinger.github.io/post/machine-learning-basics/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/machine-learning-basics/</guid>
      <description> &lt;iframe
       src=&#34;./machine-learning-basics.html&#34;
       width=&#34;90%&#34;
       height=&#34;9900px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Python built-in heroes</title>
      <link>https://fabiangunzinger.github.io/post/python-built-in-heroes/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/python-built-in-heroes/</guid>
      <description> &lt;iframe
       src=&#34;./python-built-in-heroes.html&#34;
       width=&#34;90%&#34;
       height=&#34;10500px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>The waiting time paradox</title>
      <link>https://fabiangunzinger.github.io/post/paradox/</link>
      <pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/paradox/</guid>
      <description> &lt;iframe
       src=&#34;./waiting-time-paradox.html&#34;
       width=&#34;90%&#34;
       height=&#34;11700&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>Naive Bayes</title>
      <link>https://fabiangunzinger.github.io/post/naive-bayes/</link>
      <pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://fabiangunzinger.github.io/post/naive-bayes/</guid>
      <description> &lt;iframe
       src=&#34;./naive-bayes.html&#34;
       width=&#34;90%&#34;
       height=&#34;2100px&#34;
       style=&#34;border:none;&#34;&gt;
 &lt;/iframe&gt;
</description>
    </item>
    
  </channel>
</rss>
